=== Functions

Functions are defined with arguments seperated by whitespace:

[source, morloc]
----
foo x = g (f x)
----

Here `foo` is the Morloc function name and `x` is its first argument.

The Morloc `internal` module, which is imported into all `root` modules, defines
the composition (`.`) and application (`$`) operators.

With `.` , we can re-write `foo` as:

[source, morloc]
----
foo = g . f
----

Composition chains can build multi-stage pipelines:

[source, morloc]
----
process = format . transform . validate . parse
----

The `$` operator is the application operator. It has the lowest precedence, so
it can be used to avoid parentheses:

[source, morloc]
----
-- these are equivalent
foo (bar (baz x))
foo $ bar $ baz x
----

Morloc supports partial application of arguments.

For example, to multiply every element in a list by 2, we can write:

[source, morloc]
----
multiplyByTwo = map (mul 2)
----

Partial application works well for leading arguments, but what if we want to
partially apply a later argument?

For example, we can use direct partial application with subtraction to create
functions that subtract the input argument from a given value:

[source, morloc]
----
map (sub 1) [1,2,3] -- returns [0,-1,-2]
----

But what if we want to do the reverse:

[source, morloc]
----
map ??? [1,2,3] -- we want to return [0,1,2]
----

One solution is to use anonymous function, lambdas, like so:

[source, morloc]
----
map (\x -> sub x 1) [1,2,3] -- returns [0,1,2]
----

Morloc also supports a shortcut for more flexible partial application using
underscores as placeholders:

[source, morloc]
----
map (sub _ 1) [1,2,3] -- returns [0,1,2]
----

This will be transformed in the compiler frontend to a lambda, so is behaves
identically. These placeholders may also be used in data structures. The
following two expressions obtain the same result:

[source, morloc]
----
map (\x -> (x,42)) [1,2,3] 
map (_,42) [1,2,3]
----

The placeholders may be used in nested data structures as well:

[source, morloc]
----
people :: [Person]
people = zipWith { country = "Pangea", name = _, age = _ } ["Alice", "Bob"] [42, 44]   
----

When multiple placeholders are used, the arguments generated for the lambda are
applied in left-to-right order.

Placeholders also work in string interpolation:

[source, morloc]
----
map "Hello #{_}!" ["Alice", "Bob"]
----

=== Native Morloc functions

While Morloc's primary purpose is composing foreign functions, you can also
define functions entirely in Morloc without sourcing from any language. These
_native_ functions are written using Morloc's own expression syntax:

[source, morloc]
----
module main (double, greet)

import root-py

double :: Real -> Real
double x = x + x

greet :: Str -> Str
greet name = "Hello #{name}!"
----

Native functions can use composition, `where` clauses, lambdas, and all other
Morloc expression forms. They are compiled down to whichever language the
compiler selects for execution.


