=== Binary forms

Every Morloc general type maps unambiguously to a binary form that consists of
several fixed-width literal types, a list container, and a tuple container. The
literal types include a unit type, a boolean, signed integers (8, 16, 32, and 64
bit), unsigned integers (8, 16, 32, and 64 bit), and IEEE floats (32 and 64 bit). The
list container is represented by a 64-bit size integer and a pointer to an
unboxed vector. The tuple is represented as a set of values in contiguous
memory. These basic types are listed below:

.Morloc primitives
[cols="2, 1, 2, 1"]
|===
| Type | Domain | Schema | Width (bytes)

| Unit | `()` | z | 1
| Bool | `True` \| `False` | b | 1
| UInt8 | latexmath:[[0,2^{8})] | u1 | 1
| UInt16 | latexmath:[[0,2^{16})] | u2 | 2
| UInt32 | latexmath:[[0,2^{32})] | u4 | 4
| UInt64 | latexmath:[[0,2^{64})] | u8 | 8
| Int8 | latexmath:[[-2^{7},2^{7})] | i1 | 1
| Int16 | latexmath:[[-2^{15},2^{15})] | i2 | 2
| Int32 | latexmath:[[-2^{31},2^{31})] | i4 | 4
| Int64 | latexmath:[[-2^{63},2^{63})] | i8 | 8
| Float32 | IEEE float | f4 | 4
| Float64 | IEEE double | f8 | 8
| List x | het lists | a{x} | latexmath:[16 + n \Vert a \Vert ]
| Tuple2 x1 x2 | 2-ples | t2{x1}{x2} | latexmath:[\Vert a \Vert + \Vert b \Vert]
| TupleX latexmath:[\ t_i\ ...\ t_k] | k-ples | latexmath:[tkt_1\ ...\ t_k] | latexmath:[\sum_i^k \Vert t_i \Vert]
| latexmath:[\{ f_1 :: t_1,\ ... \ , f_k :: t_k \}] | records | latexmath:[mk \Vert f_1 \Vert f_1 t_1\ ...\ \Vert f_k \Vert f_k t_k ] | latexmath:[\sum_i^k \Vert t_i \Vert]
|===

All basic types may be written to a schema that is used internally to direct
conversions between Morloc binary and native basic types. The schema values
are shown in the table above. For example, the type `[(Bool, [Int8])]` would
have the schema `at2bai1`. You will not usually have to worry about these
schemas, since they are mostly used internally. They are worth knowing, though,
since they appear in low-level tests, generated source code, and binary data
packets.

Here is an example of how the type `([UInt8], Bool)`, with the value
`([3,4,5],True)`,  might be laid out in memory:

[source]
---
03 00 00 00 00 00 00 00 00 -- first tuple element, specifies list length (little-endian)
30 00 00 00 00 00 00 00 00 -- first tuple element, pointer to list
01 00 00 00 00 00 00 00 00 -- second tuple element, with 0-padding
03 04 05                   -- 8-bit values of 3, 4, and 5
---

Records and tables are represented as tuples. The names for each field are stored only in
the type schemas. Morloc also supports tables, which are just records where
the field types correspond to the column types and where fields are all
equal-length lists. Records and tables may be defined as shown below:

A `record` is a named, heterogenous list such as a `struct` in C, a `dict` in
Python, or a `list` in R. The type of the record exactly describes the data
stored in the record (in contrast to parameterized types like `[a]` or `Map a
b`). They are represented in Morloc binary as tuples, the keys are only stored
in the schemas.

A `table` is like a record where field types represent the column types. But
`table` is not just syntactic sugar for a record of lists, the `table`
annotation is passed with the record through the compiler all the way to the
translator, where the language-specific serialization functions may have special
handling for tables.

[source, morloc]
----
record Person = Person { name :: Str, age :: UInt8 }
table People = People { name :: Str, age :: Int }

alice = { name = "Alice", age = 27 }
students = { name = ["Alice", "Bob"], age = [27, 25] }
----

The Morloc type signatures can be translated to schema strings that may be
parsed by a foundational Morloc C library into a type structure. Every
supported language in the Morloc ecosystem must provide a library that wraps
this Morloc C library and translates to/from Morloc binary given the
Morloc type schema.


