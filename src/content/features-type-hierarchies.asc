=== Type hierarchies

In some cases, there is a single obvious native type for a given Morloc general
type. For example, most languages have exactly only one reasonable way to
represent a boolean. However, other data types have may have many forms. The
Morloc `List` is a simple example. In Python, the `list` type is most often used
for representing ordered lists, however it is inefficient for heavy numeric
problems. In such cases, it is better to use a `numpy` vector. Further, there
are data structures that are isomorphic to lists but that are more efficient for
certain problems, such as stacks and queues.

We can define type hierarchies that represent these relationships.

[source, morloc]
----
-- aliases at the general level
type Stack       a = List a
type LList       a = List a
type ForwardList a = List a
type Deque       a = List a
type Queue       a = List a
type Vector      a = List a


-- define a C++ specialization for each special type
type Cpp => Stack a = "std::stack<$1>" a
type Cpp => LList a = "std::list<$1>" a
type Cpp => ForwardList a = "std::forward_list<$1>" a
type Cpp => Deque a = "std::deque<$1>" a
type Cpp => Queue a = "std::queue<$1>" a
----

Here we equate each of the specialized containers with the general `List`
type. This indicates that they all share the same common form and can all be
converted to the same binary. Then we specify language specific patterns as
desired. When the Morloc compiler seeks a native form for a type, it will
evaluate these type functions by incremental steps. At each step the compiler
first checks to see if there is a direct native mapping for the language, if
none is found, it evaluates the general type function.

Native type annotations are also passed to the language binders, allowing them
to implement specialized behavior for more efficient conversion to binary.


