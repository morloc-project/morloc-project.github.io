=== Tables

Tables are similar, but all fields are lists of equal length:

[source, morloc]
----
module foo (readPeople, addPeople)

import root-py (Int, Str)

source R from "people-tables.R"
   ( "read.delim" as readPeople
   , "addPeople")

table People = People
    { name :: Str
    , age :: Int
    }

readPeople :: Filename -> People
addPeople :: [Str] -> [Int] -> People -> People
----

With "people-tables.R" containing:

[source, r]
----
addPeople <- function(names, ages, df){
    rbind(df, data.frame(name = names, age = ages)) 
}
----

This can be compiled and run as so:

[source, bash]
----
# read a tab-delimited file containing person rows
./nexus readPeople data.tab > people.json

# add a row to the table
./nexus addPeople '["Eve"]' '[99]' people.json
----

The record and table types are currently strict. Defining functions that add or
remove fields/columns requires defining entirely new records/tables. Generic
functions for operations such as removing lists of columns cannot be defined at
all. For now, most operations should be done in coarser functions.
Alternatively, custom non-parameterized tabular/record types may be defined.

The case study in the Morloc
https://www.zebulun-arendsee.com/images/morloc-paper-001.pdf[paper] uses a
`JsonObj` type that represents an arbitrarily nested object that serializes
to/from JSON. In Python, it deserializes to a `dict` object; in R, to a `list`
objects; and in C to an `ordered_json` object from from
(https://github.com/nlohmann)[Niels Lohmann's json package]).

A similar approach could be used to define a non-parameterized table type that
serialized to CSV or some binary type (such as Parquet).

These non-parameterized solutions are flexible and easy to use, but lack the
reliability of the typed structures.


