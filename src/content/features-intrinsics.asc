
=== Intrinsics

Intrinsics are compiler-generated special functions. They are prefixed with `@`
and provide capabilities that cannot be implemented as ordinary sourced
functions -- they require the compiler to generate specialized code based on the
types involved.

==== Reference table

[cols="1,2,3", options="header"]
|===
| Intrinsic | Signature | Description

| `@save`
| `a -> Str -> {()}`
| Save a value to file in flat binary format (fast, no serialization overhead)

| `@savem`
| `a -> Str -> {()}`
| Save a value to file in MessagePack format (portable, compact)

| `@savej`
| `a -> Str -> {()}`
| Save a value to file as plain JSON text (human-readable)

| `@load`
| `Str -> {?a}`
| Load a value from file, auto-detecting the format. Returns `null` if the file does not exist.

| `@hash`
| `a -> Str`
| Hash a value via MessagePack serialization (xxhash), returns a 16-character hex string

| `@version`
| `Str`
| The compiler version string (resolved at compile time)

| `@compiled`
| `Str`
| The compilation timestamp (resolved at compile time)

| `@lang`
| `Str`
| The name of the language used in the current pool (resolved at compile time)

| `@schema`
| `a -> Str`
| The serialization schema string for the given type (value is ignored at runtime)

| `@typeof`
| `a -> Str`
| The concrete runtime type name for the given type (value is ignored at runtime)
|===

All intrinsics are polymorphic in their data argument: `@save`, `@savem`,
`@savej`, `@hash`, `@schema`, and `@typeof` accept a value of any type. `@load`
returns a value of any type, inferred from context. The `@save`/`@savem`/`@savej`
functions return thunks (`{()}`) because they perform I/O and must be forced
to execute.


==== Saving and loading data

The `@save`, `@savem`, and `@savej` intrinsics write a value to a file path.
`@load` reads it back. Together they provide a type-safe file persistence
mechanism.

`@save` uses the flat binary format, which is the fastest option -- the value's
in-memory representation is written almost directly to disk with no
serialization overhead. `@savem` uses MessagePack, which is compact and portable
across different machines and architectures. `@savej` writes plain JSON, which
is human-readable and can be edited by hand or consumed by other tools.

`@load` auto-detects the file format. Files written by `@save` or `@savem`
carry a small header that `@load` uses to distinguish the binary and MessagePack
formats. If no header is present, `@load` tries to parse the file as JSON. This
means `@load` can read files written by any of the three save intrinsics, and it
can also read plain JSON files that were created outside of Morloc.

Since `@load` returns `{?a}`, it is a thunk that yields an optional value. If
the file does not exist, the result is `null` rather than an error. This makes
it natural to use `@load` for optional configuration or cached data.

Here is a basic round-trip example:

[source,morloc]
----
module main (roundTrip)

import root-py (id)

roundTrip :: Int -> Str -> {?Int}
roundTrip x path = do
  @save (id x) path
  @load path
----

The `@save` call writes the integer to the given path. Then `@load` reads it
back. Because `@load` is used as the final expression in a `do` block, its
thunk is the return value of `roundTrip`.

You can also use `@savej` when you want the output to be readable:

[source,morloc]
----
module main (saveReadable)

import root-py (id)

saveReadable :: [Str] -> {()}
saveReadable xs = @savej (id xs) "output.json"
----

The resulting `output.json` file is plain JSON that can be inspected in any text
editor.


==== Caching with save and load

A common pattern is to check whether a cached result exists before recomputing
it. Since `@load` returns `null` when the file is missing, you can branch on
the result:

[source,morloc]
----
module main (cachedResult)

import root-py (id, fromNull)

source Py from "compute.py" ("expensiveComputation")
expensiveComputation :: Int -> Int

cachedResult :: Int -> Str -> {Int}
cachedResult x cachePath = do
  cached <- @load cachePath
  let result = fromNull (expensiveComputation x) cached
  @save (id result) cachePath
  {result}
----

On the first call, `@load` returns `null` because the cache file does not exist.
`fromNull` falls through to calling `expensiveComputation`. The result is saved
for future calls. On subsequent calls, `@load` returns the cached value and
`fromNull` uses it directly, skipping the computation.

You can also use `@hash` to build content-addressed caches where the cache path
depends on the input:

[source,morloc]
----
module main (hashedCache)

import root-py (id, concat, fromNull)

source Py from "compute.py" ("expensiveComputation")
expensiveComputation :: Int -> Int

hashedCache :: Int -> {Int}
hashedCache x = do
  let key = @hash (id x)
  let cachePath = concat ["/tmp/cache_", key, ".bin"]
  cached <- @load cachePath
  let result = fromNull (expensiveComputation x) cached
  @save (id result) cachePath
  {result}
----

Each distinct input gets its own cache file, keyed by the xxhash of its
serialized form.


==== Hashing

`@hash` computes a fast, non-cryptographic hash (xxhash) of any value. The
value is first serialized to MessagePack internally, then hashed. The result is
a 16-character hexadecimal string.

[source,morloc]
----
module main (hashInt, hashStr)

import root-py (id)

hashInt :: Int -> Str
hashInt x = @hash (id x)

hashStr :: Str -> Str
hashStr x = @hash (id x)
----

Hashing is deterministic: the same value always produces the same hash. Two
values of different types may hash differently even if they look similar (e.g.,
the integer `1` and the string `"1"`), because their MessagePack serializations
differ.


==== Compile-time constants

The `@version`, `@compiled`, and `@lang` intrinsics are resolved at compile
time. They can be used anywhere a `Str` value is expected.

[source,morloc]
----
module main (info)

import root-py (id)

info :: [Str]
info = id [@version, @compiled, @lang]
----

Running `./info info` might produce:

----
["0.50.0", "2026-02-27T10:30:00Z", "python3"]
----

`@lang` returns the language of the pool where the expression is evaluated. If
the expression is realized in Python, it returns `"python3"`; in {cpp}, it
returns `"cpp"`. This is useful for debugging or for conditional logic based on
which language backend is in use.


==== Type introspection

The `@schema` and `@typeof` intrinsics return information about how the compiler
represents a type. The value argument is not evaluated at runtime -- only its
type matters.

[source,morloc]
----
module main (showSchema, showType)

import root-py (id)

showSchema :: Int -> Str
showSchema x = @schema (id x)

showType :: Int -> Str
showType x = @typeof (id x)
----

`@schema` returns the internal serialization schema string used by the compiler
for MessagePack and binary serialization. `@typeof` returns the concrete type
name in the current language (e.g., `"int"` in Python, `"int"` in {cpp}).
These are primarily useful for debugging and diagnostics.

