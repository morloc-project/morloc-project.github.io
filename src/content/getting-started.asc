
=== Installing Morloc

The easiest way to run Morloc is through containers in a UNIX environment. Linux
will work natively. MacOS and Windows are more complicated and I'll deal with
their special later on. For Windows, you will need to install through the
https://learn.microsoft.com/en-us/windows/wsl/about[Windows Subsystem for Linux].

The only dependency is a container engine, currently two --
https://docs.docker.com/engine/install/[docker] and
https://podman.io/docs/installation[podman] -- are supported.

.Podman instructions
[%collapsible]
====

Unlike Docker, `podman` runs rootless by default, so no sudo is required. On
Linux, it also runs natively with no daemons.

On MacOS and Windows (even through WSL), a virtual machine is required. So you
will need to initialize `podman` as so:

[%nowrap, console]
----
$ podman init
$ podman start
----

You can confirm that podman is running by entering

[%nowrap, console]
----
$ podman --version
podman version 5.4.1   # version on my current setup
----

++++
<hr>
++++

====

.Docker instructions
[%collapsible]
====

Docker requires either sudo access or
https://docs.docker.com/engine/security/rootless/[rootless mode] configuration.

Verify Docker is running:

[%nowrap, console]
----
$ docker --version
$ docker run hello-world
----

++++
<hr>
++++

====


After confirming either Podman or Docker is running on your system, pull an
installation script from
https://github.com/morloc-project/morloc-manager[morloc-project/morloc-manager]:

[%nowrap, console]
----
$ curl -o morloc-manager https://raw.githubusercontent.com/morloc-project/morloc-manager/refs/heads/main/morloc-manager.sh
----

`morloc-manager` is a (mostly) POSIX compatible shell script that is tested on Linux and
MacOS. On Windows, you should may run this in the Windows Subsystem for Linux
(WSL). You may execute `morloc-manager` directly, for example `bash morloc-manager`. But it is more
convenient to make the script executable and move it to a folder in your
execution path.

The script provides usage information on request:

[%nowrap, console]
----
$ morloc-manager -h
$ morloc-manager install -h
$ morloc-manager uninstall -h
----

The `install` subcommand will build the Morloc home directory, install required
containers, and generate executable scripts. The two you need are `menv` and
`morloc-shell`.

`menv` runs arbitrary commands in a Morloc container. It can be used to compile
and run Morloc programs. For example:

[%nowrap, console]
----
$ menv morloc make -o foo foo.loc
$ menv ./foo double 21
----

`morloc-shell` is the same as the above script except that you enter the
container in an interactive shell rather than just running one command. The
container has installations for Python, R, and C++ compiler as well as
vim and other conveniences.

=== Setting up IDEs

We are currently working on expanding the editor support for Morloc.

Here are supported editors

.vim
[%collapsible]
====

If you are working in vim, you can install Morloc syntax highlighting as
follows:

[%nowrap, console]
----
$ mkdir -p ~/.vim/syntax/
$ mkdir -p ~/.vim/ftdetect/
$ curl -o ~/.vim/syntax/loc.vim https://raw.githubusercontent.com/morloc-project/vimmorloc/main/loc.vim
$ echo 'au BufRead,BufNewFile *.loc set filetype=loc' > ~/.vim/ftdetect/loc.vim
----

image::vim-highlights.png[]

++++
<hr>
++++
====

.VS Code / VSCodium / Cursor
[%collapsible]
====

We have a publicly available "morloc" extension with support for highlighting
and snippet expansion.

image::vscode-highlights.png[]

++++
<hr>
++++

====

.Zed
[%collapsible]
====

This is currently under development, see repo https://github.com/morloc-project/zed-morloc[here].

The extension is mostly written, and the required Tree-sitter grammar is
written, but there are bugs to be resolved. I'm happy to accept pull requests!

====

I've also written several syntax highlighting and static analysis tools:

.Pygmentize
[%collapsible]
====

A repo with the Pygmentize parser can be found
https://github.com/morloc-project/pygmentize[here]. This parser is used to
highlight code here in the manual. It can be easily integrated into Python code,
e.g., in the https://github.com/morloc-project/weena-bot[Weena discord bot].

====

.Tree-sitter
[%collapsible]
====

Tree-sitter is a program for defining parsers and using them to query languages
and add advanced grammatical understanding to editors. These grammars require a
complete lexer and parser specification for the language. This grammar is
available for Morloc, see repo
https://github.com/morloc-project/tree-sitter-morloc[here]. Tree-sitter allows
general purpose syntax highlighting (e.g., over the command line) and parses a
full concrete syntax tree from the code:

image::tree-sitter.png[]

====

=== Say hello

The inevitable "Hello World" case is implemented in Morloc like so:

[source, morloc]
----
module main (hello)
hello = "Hello up there"
----

The module named `main` exports the term `hello` which is assigned to a literal
string value.

Paste this code into a file (e.g. "hello.loc") and then it can be imported by
other Morloc modules or directly compiled into a program where every exported
term is a subcommand.

[source, console]
----
$ morloc make hello.loc
----

This command will produce an executable named `nexus` (a copy of the pre-compiled
nexus binary) along with a `nexus.manifest` JSON file and pool files for each
language used (e.g., `pool.py`, `pool-cpp.out`, `pool.R`). The `nexus` is the
command line interface (CLI) to the commands exported from the module.

// NOTE: Functions arguments are separated by whitespace

Calling `nexus` with no arguments or with the `-h` flag, will print a help
message:

[source, console]
----
$ ./nexus -h
Usage: ./nexus [OPTION]... COMMAND [ARG]...

Nexus Options:
 -h, --help            Print this help message
 -o, --output-file     Print to this file instead of STDOUT
 -f, --output-format   Output format [json|mpk|voidstar]

Exported Commands:
  hello
    return: Str
----


This usage message is automatically generated. For each exported term, it
specifies the input (none, in this case) and output types as inferred by the
compiler. For this case, the exported command is just the term `hello`, so no
input types are listed.

The command is called as so:

[source, console]
----
$ ./nexus hello
Hello up there
----

=== Dice rolling

Let's write a little program rolls a pair of 20-sided dice and prints the larger
result. Here is the Morloc script:

[source, morloc]
----
module dnd (rollAdv)
import types
source Py from "foo.py" ("roll", "max", "narrate")

roll :: Int -> Int -> [Int]
max :: [Int] -> Int
narrate :: Int -> Str

rollAdv = narrate (max (roll 2 20))
----

Here we define a module named `dnd` that exports the function `rollAdv`. In line
2, we import the required type definitions from the Morloc module
`types`. Later on we'll go into how these types are defined. In line 3, we
source three functions from the Python file "foo.py". In lines 5-8, we assign
each of these functions a Morloc type signature. You can think of the arrows
in the signatures as separating arguments. For example, the function `roll`
takes two integers as arguments and returns a list of integers. The square
brackets indicate lists. In the final line, we define the `rollAdv` function.

The Python functions are sourced from the Python file "foo.py" with the
following code:

[source, python]
----
import random

def roll(n, d):
    # Roll an n-sided die d times, return a list of results
    return [random.randint(1, d) for _ in range(n)]

def narrate(roll_value):
    return f"You rolled a {roll_value!s}"
----

Nothing about this code is particular to Morloc.

One of Morloc's core values is that foreign source code _never_ needs to know
anything about the Morloc ecosystem. Sourced code should always be nearly
idiomatic code that uses normal data types. The inputs and outputs of these
functions are natural Python integers, lists, and strings -- they are not
Morloc-specific serialized data or ad hoc textual formats.

This module is dependent on the `types` module, which in turn is dependent on
the `prelude` module. So before compiling, we need to import both of these:

[source, console]
----
morloc install prelude
morloc install types
----

Now we can compile and run this program as so:

[source, console]
----
$ morloc make main.loc
$ ./nexus rollAdv
"You rolled a 20"
----

As a random function, it will return a new result every time.

So, what's the point? We could have done this more easily in a pure Python
script. Morloc generates a CLI for us, type checks the program, and performs
some runtime validation (by default, just on the final inputs and outputs). But
there are other tools in the Python universe can achieve this same end. Where
Morloc is uniquely valuable is in the polyglot setting.

=== Polyglot dice rolling

In this next example, we rewrite the prior dice example with all three functions
being sourced from different languages:

[source, morloc]
----
module dnd (rollAdv)

import types

source R from "foo.R" ("roll")
source Cpp from "foo.hpp" ("max")
source Py from "foo.py" ("narrate")

roll :: Int -> Int -> [Int]
max :: [Int] -> Int
narrate :: Int -> Str

rollAdv = narrate (max (roll 2 20))
----

Note that all of this code is exactly the same as in the prior example except
the source statements.

The `roll` function is defined in R:

[source, r]
----
roll <- function(n, d){
    sample(1:d, n)
}
----

The `max` function is defined in {cpp}:

[source, c++]
----
#pragma one
#include <vector>
#include <algorithm>

template <typename A>
A max(const std::vector<A>& xs) {
    return *std::max_element(xs.begin(), xs.end());
}
----

The `narrate` function is defined in Python:

[source, python]
----
def narrate(roll_value):
    return f"You rolled a {roll_value!s}"
----

This can be compiled and run in exactly the same way as the prior monoglot
example. It will run a bit slower, mostly because of the heavy cost of starting
the R interpreter.

The Morloc compiler automatically generates all code required to translate data
between the languages. Exactly how this is done will be discussed later.

=== Parallelism example

Here is an example showing a parallel map function written in Python that calls {cpp} functions.

[source, morloc]
----
module m (sumOfSums)

import types

source Py from "foo.py" ("pmap")
source Cpp from "foo.hpp" ("sum")

pmap a b :: (a -> b) -> [a] -> [b]
sum :: [Real] -> Real

sumOfSums = sum . pmap sum
----

This Morloc script exports a function that sums a list of lists of real
numbers. Here we use the dot operator for function composition. The sum function
is implemented in {cpp}:

[source, c++]
----
// C++ header sourced by morloc script
#pragma one
#include <vector>

double sum(const std::vector<double>& vec) {
    double sum = 0.0;
    for (double value : vec) {
        sum += value;
    }
    return sum;
}
----

The parallel `pmap` function is written in Python:

[source, python]
----
# Python3 file sourced by morloc script
import multiprocessing as mp

def pmap(f, xs):
    with mp.Pool() as pool:
        results = pool.map(f, xs)
    return results
----

The inner summation jobs will be run in parallel. The `pmap` function has the
same signature as the non-parallel `map` function, so can serve as a drop-in
replacement.

This can be compiled and run with the lists being provided in JSON format:

[source, console]
----
$ morloc make main.loc
$ ./nexus sumOfSums '[[1,2],[3,4,5]]'
----
