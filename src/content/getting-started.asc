
=== Install the compiler

The easiest way to start using Morloc is through containers. I recommend using
podman, since it doesn't require a daemon or sudo access. But Docker,
Singularity, and other container engines are fine as well.

An image with the morloc executable and batteries included can be retrieved
from the GitHub container registry as follows:

[source, bash]
----
$ podman pull ghcr.io/morloc-project/morloc/morloc-full:0.53.7
----

The `v0.53.7` may be replaced with the desired Morloc version.

Now you can enter a shell with a full working installation of Morloc:

[source, bash]
----
$ podman run --shm-size=4g \
             -v $HOME:$HOME \
             -w $PWD \
             -e HOME=$HOME \
             -it ghcr.io/morloc-project/morloc/morloc-full:0.53.7 \
             /bin/bash
----

The `--shm-size=4g` option sets the shared memory space to 4GB. Morloc uses
shared memory for communication between languages, but containers often limit
the shared memory space to 64MB by default. By mounting your home directory, the
changes you make in the container (including the installation of Morloc
modules) will be persistent across sessions.

Alternatively, you can set up a script to run commands in a Morloc environment:

[source, bash]
----
podman run --rm \
           --shm-size=4g \
           -e HOME=$HOME \
           -v $HOME/.morloc:$HOME/.morloc \
           -v $PWD:$HOME \
           -w $HOME \
           ghcr.io/morloc-project/morloc/morloc-full:0.53.7 "$@"
----

Name this script `menv`, for "morloc environment", make it executable (`chmod
755 menv`), and place it in a bin folder on your PATH. The script will mount
your current working directory and your Morloc home directory, allowing you to
run commands in a morloc-compatible environment.

With this script, can run commands like so:

[source, bash]
----
$ menv morloc --version             # get the current morloc version
$ menv morloc -h                    # list morloc commands
$ menv morloc init -f               # setup the morloc environment
$ menv morloc install types         # install a morloc module
$ menv morloc make -o foo foo.loc   # compile a local morloc module
----

The last command builds a Morloc program with the executable "foo" from the
Morloc script file "foo.loc". The generated executable may not work on your
system since it was compiled within the container environment, so you should run
it in the container environment as well:

[source, bash]
----
$ menv ./foo bar 1 2 3
----

More advanced solutions with richer dependency handling will be introduced in
the future, but for now this allows easy experimentation with the language in a
safe(ish) sandbox.

The `menv morloc` or `menv ./foo` syntax is a bit verbose, but I'll let you play
with alternative aliases. The conventions here are still fluid. Let me know if
you find something better and or if you find bugs in this approach.


=== Setting up IDEs

Editor support for Morloc is still a work in progress.

If you are working in vim, you can install Morloc syntax highlighting as
follows:

[source]
----
mkdir -p ~/.vim/syntax/
mkdir -p ~/.vim/ftdetect/
curl -o ~/.vim/syntax/loc.vim https://raw.githubusercontent.com/morloc-project/vimmorloc/main/loc.vim
echo 'au BufRead,BufNewFile *.loc set filetype=loc' > ~/.vim/ftdetect/loc.vim
----

Developing a full plugin is left as an excercise for the user (pull requests welcome).

If you are working in VS Code, I've made a simple extension that offers syntax
highlighting and snippets. You can pull the extension from GitHub and move it
into your VS code extensions folder:

[source, bash]
----
git clone https://github.com/morloc-project/vscode ~/.vscode-oss/extensions/morloc
----

Update the path to the extensions folder as needed on your system. This manually
installs the extensions, which is not ideal. I'll push the extension to the
official VS Code package manager soon.


=== Say hello

The inevitable "Hello World" case is implemented in Morloc like so:

[source, morloc]
----
module main (hello)
hello = "Hello up there"
----

The module named `main` exports the term `hello` which is assigned to a literal
string value.

Paste this code into a file (e.g. "hello.loc") and then it can be imported by
other Morloc modules or directly compiled into a program where every exported
term is a subcommand.

[source]
----
morloc make hello.loc
----

This command will produce two files: a C program, `nexus.c`, and its compiled
binary, `nexus`. The `nexus` is the command line interface (CLI) to the commands
exported from the module.

Calling `nexus` with no arguments or with the `-h` flag, will print a help
message:

[source]
----
$ ./nexus -h
The following commands are exported:
  hello
    return: Str
----

This usage message is automatically generated. For each exported term, it
specifies the input (none, in this case) and output types as inferred by the
compiler. For this case, the exported command is just the term `hello`, so no
input types are listed.

The command is called as so:

[source]
----
$ ./nexus hello
Hello up there
----

=== Dice rolling

Let's write a little program rolls a pair of 20-sided dice and prints the larger
result. Here is the Morloc script:

[source, morloc]
----
module dnd (rollAdv)
import types
source Py from "foo.py" ("roll", "max", "narrate")

roll :: Int -> Int -> [Int]
max :: [Int] -> Int
narrate :: Int -> Str

rollAdv = narrate (max (roll 2 20))
----

Here we define a module named `dnd` that exports the function `rollAdv`. In line
2, we import the required type definitions from the Morloc module
`types`. Later on we'll go into how these types are defined. In line 3, we
source three functions from the Python file "foo.py". In lines 5-8, we assign
each of these functions a Morloc type signature. You can think of the arrows
in the signatures as separating arguments. For example, the function `roll`
takes two integers as arguments and returns a list of integers. The square
brackets indicate lists. In the final line, we define the `rollAdv` function.

Note that arguments passed to functions are separated by whitespace, so the
mathematical function `f(x, y)` would be represented as `f x y`.

The Python functions are sourced from the Python file "foo.py" with the
following code:

[source, python]
----
import random

def roll(n, d):
    # Roll an n-sided die d times, return a list of results
    return [random.randint(1, d) for _ in range(n)]

def narrate(roll_value):
    return f"You rolled a {roll_value!s}"
----

Note that nothing about this code is particular to Morloc. One of Morloc's core
values is that foreign source code _never_ needs to know anything about the
Morloc ecosystem. Sourced code should always be nearly idiomatic code that uses
normal data types. The inputs and outputs of these functions are natural Python
integers, lists, and strings -- they are not Morloc-specific serialized data or
ad hoc textual formats.

We can compile and run this program as so:

[source]
----
$ morloc make main.loc
$ ./nexus rollAdv
"You rolled a 20"
----

As a random function, it will return a new result every time.

So, what's the point? We could have done this more easily in a pure Python
script. Morloc generates a CLI for us, type checks the program, and performs
some runtime validation (by default, just on the final inputs and outputs). But
there are other tools in the Python universe can achieve this same end. Where
Morloc is uniquely valuable is in the polyglot setting.

=== Polyglot dice rolling

In this next example, we rewrite the prior dice example with all three functions
being sourced from different languages:

[source, morloc]
----
module dnd (rollAdv)

import types

source R from "foo.R" ("roll")
source Cpp from "foo.hpp" ("max")
source Py from "foo.py" ("narrate")

roll :: Int -> Int -> [Int]
max :: [Int] -> Int
narrate :: Int -> Str

rollAdv = narrate (max (roll 2 20))
----

Note that all of this code is exactly the same as in the prior example except
the source statements.

The `roll` function is defined in R:

[source, r]
----
roll <- function(n, d){
    sample(1:d, n)
}
----

The `max` function is defined in {cpp}:

[source, c++]
----
#pragma one
#include <vector>
#include <algorithm>

template <typename A>
A max(const std::vector<A>& xs) {
    return *std::max_element(xs.begin(), xs.end());
}
----

The `narrate` function is defined in Python:

[source, python]
----
def narrate(roll_value):
    return f"You rolled a {roll_value!s}"
----

This can be compiled and run in exactly the same way as the prior monoglot
example. It will run a bit slower, mostly because of the heavy cost of starting
the R interpreter.

The Morloc compiler automatically generates all code required to translate data
between the languages. Exactly how this is done will be discussed later.

=== Parallelism example

Here is an example showing a parallel map function written in Python that calls {cpp} functions.

[source, morloc]
----
module m (sumOfSums)

import types

source Py from "foo.py" ("pmap")
source Cpp from "foo.hpp" ("sum")

pmap a b :: (a -> b) -> [a] -> [b]
sum :: [Real] -> Real

sumOfSums = sum . pmap sum
----

This Morloc script exports a function that sums a list of lists of real
numbers. Here we use the dot operator for function composition. The sum function
is implemented in {cpp}:

[source, c++]
----
// C++ header sourced by morloc script
#pragma one
#include <vector>

double sum(const std::vector<double>& vec) {
    double sum = 0.0;
    for (double value : vec) {
        sum += value;
    }
    return sum;
}
----

The parallel `pmap` function is written in Python:

[source, python]
----
# Python3 file sourced by morloc script
import multiprocessing as mp

def pmap(f, xs):
    with mp.Pool() as pool:
        results = pool.map(f, xs)
    return results
----

The inner summation jobs will be run in parallel. The `pmap` function has the
same signature as the non-parallel `map` function, so can serve as a drop-in
replacement.

This can be compiled and run with the lists being provided in JSON format:

[source, bash]
----
$ morloc make main.loc
$ ./nexus sumOfSums '[[1,2],[3,4,5]]'
----

The `types` module contains definitions such as below:

[source, morloc]
----
type Cpp => List a = "std::vector<$1>" a
type Py => List a = "list" a

type Cpp => Real = "double"
type Py => Real = "float"
----
