
=== Installing Morloc

The easiest way to run Morloc is through containers in a UNIX environment. Linux
will work natively. MacOS and Windows are more complicated and I'll deal with
their special later on. For Windows, you will need to install through the
https://learn.microsoft.com/en-us/windows/wsl/about[Windows Subsystem for Linux].

The only dependency is a container engine, currently two
https://docs.docker.com/engine/install/[docker] and
https://podman.io/docs/installation[podman] are supported.

.Podman instructions
[%collapsible]
====

Unlike Docker, `podman` runs rootless by default, so no sudo is required. On
Linux, it also runs natively with no daemons.

On MacOS and Windows (even through WSL), a virtual machine is required. So you
will need to initialize `podman` as so:

[%nowrap, console]
----
$ podman init
$ podman start
----

You can confirm that podman is running by entering

[%nowrap, console]
----
$ podman --version
podman version 5.4.1   # version on my current setup
----

++++
<hr>
++++

====

.Docker instructions
[%collapsible]
====

TBD

++++
<hr>
++++

====


After confirming either Podman or Docker is running on your system, pull an
installation script from
https://github.com/morloc-project/morloc-manager[morloc-project/morloc-manager]:

[%nowrap, console]
----
$ curl -o morloc-manager https://raw.githubusercontent.com/morloc-project/morloc-manager/refs/heads/main/morloc-manager.sh
----

The script provides usage information on request:

[%nowrap, console]
----
$ sh morloc-manager -h
$ sh morloc-manager install -h
$ sh morloc-manager uninstall -h
----

The `install` subcommand will build the Morloc home directory, install required
containers, and generate four executable scripts.

*The first script is `menv`*. It runs arbitrary commands in a Morloc container. It
can be used to compile and run Morloc programs. For example:

[%nowrap, console]
----
$ menv morloc make -o foo foo.loc
$ menv ./foo double 21
----

The `menv` script mounts the working directory and the `~/.morloc/<version>`
directory. It builds the program using the containers version of the Morloc
compiler and Morloc libraries that are defined in the version-specific home
directory. It cannot see any dependencies on your local system.

*The second script is `morloc-shell`*. This script is the same as the above script
except that you enter the container in an interactive shell rather than just
running one command. The container has installations for Python, R, and C++
compiler. It also contains vim and other conveniences

*The third script is `menv-dev`*. This runs commands in a dev container where all
Haskell tools required for building Morloc from source are installed. To build
Morloc from source, do the following:

[%nowrap, console]
----
$ git clone git@github.com:morloc-project/morloc
$ cd morloc
$ menv-dev stack install --fast
$ menv-dev stack test --fast
----

This will build the version that was cloned from GitHub. Now you can use
`menv-dev` as you would `menv`.

*The fourth script is `morloc-shell-dev`*. This script lets you enter the dev
shell.

The `morloc` compiler always considers `~/.morloc` to be the home directory. The
containers mount separate folders in the local `~/.morloc` folder.  This means
the different versions of Morloc installed, as well as the special `local`
version used by the dev container, do not have overlapping libraries and
modules.

Throughout the rest of this manual, whenever I show an example that uses
`morloc`, you can assume that I am running it from within a container after
calling `morloc-shell`.

=== Setting up IDEs

We are currently working on expanding the editor support for Morloc.

Here are supported editors

.vim
[%collapsible]
====

If you are working in vim, you can install Morloc syntax highlighting as
follows:

[%nowrap, console]
----
$ mkdir -p ~/.vim/syntax/
$ mkdir -p ~/.vim/ftdetect/
$ curl -o ~/.vim/syntax/loc.vim https://raw.githubusercontent.com/morloc-project/vimmorloc/main/loc.vim
$ echo 'au BufRead,BufNewFile *.loc set filetype=loc' > ~/.vim/ftdetect/loc.vim
----

image::vim-highlights.png[]

++++
<hr>
++++
====

.VS Code / VSCodium / Cursor
[%collapsible]
====

We have a publicly available "morloc" extension with support for highlighting
and snippet expansion.

image::vscode-highlights.png[]

++++
<hr>
++++

====

.Zed
[%collapsible]
====

This is currently under development, see repo https://github.com/morloc-project/zed-morloc[here].

The extension is mostly written, and the required Tree-sitter grammar is
written, but there are bugs to be resolved. I'm happy to accept pull requests!

====

I've also written several syntax highlighting and static analysis tools:

.Pygmentize
[%collapsible]
====

A repo with the Pygmentize parser can be found
https://github.com/morloc-project/pygmentize[here]. This parser is used to
highlight code here in the manual. It can be easily integrated into Python code,
e.g., in the https://github.com/morloc-project/weena-bot[Weena discord bot].

====

.TextMate
[%collapsible]
====
====

.Tree-sitter
[%collapsible]
====

Tree-sitter is a program for defining parsers and using them to query languages
and add advanced grammatical understanding to editors. These grammars require a
complete lexer and parser specification for the language. This grammar is
available for Morloc, see repo
https://github.com/morloc-project/tree-sitter-morloc[here]. Tree-sitter allows
general purpose syntax highlighting (e.g., over the command line) and parses a
full concrete syntax tree from the code:

image::tree-sitter.png[]

====

=== Say hello

The inevitable "Hello World" case is implemented in Morloc like so:

[source, morloc]
----
module main (hello)
hello = "Hello up there"
----

The module named `main` exports the term `hello` which is assigned to a literal
string value.

Paste this code into a file (e.g. "hello.loc") and then it can be imported by
other Morloc modules or directly compiled into a program where every exported
term is a subcommand.

[source, console]
----
$ morloc make hello.loc
----

This command will produce two files: a C program, `nexus.c`, and its compiled
binary, `nexus`. The `nexus` is the command line interface (CLI) to the commands
exported from the module.

// NOTE: Functions arguments are separated by whitespace

Calling `nexus` with no arguments or with the `-h` flag, will print a help
message:

[source, console]
----
$ ./nexus -h
Usage: ./nexus [OPTION]... COMMAND [ARG]...

Nexus Options:
 -h, --help            Print this help message
 -o, --output-file     Print to this file instead of STDOUT
 -f, --output-format   Output format [json|mpk|voidstar]

Exported Commands:
  hello
    return: Str
----


This usage message is automatically generated. For each exported term, it
specifies the input (none, in this case) and output types as inferred by the
compiler. For this case, the exported command is just the term `hello`, so no
input types are listed.

The command is called as so:

[source, console]
----
$ ./nexus hello
Hello up there
----

=== Dice rolling

Let's write a little program rolls a pair of 20-sided dice and prints the larger
result. Here is the Morloc script:

[source, morloc]
----
module dnd (rollAdv)
import types
source Py from "foo.py" ("roll", "max", "narrate")

roll :: Int -> Int -> [Int]
max :: [Int] -> Int
narrate :: Int -> Str

rollAdv = narrate (max (roll 2 20))
----

Here we define a module named `dnd` that exports the function `rollAdv`. In line
2, we import the required type definitions from the Morloc module
`types`. Later on we'll go into how these types are defined. In line 3, we
source three functions from the Python file "foo.py". In lines 5-8, we assign
each of these functions a Morloc type signature. You can think of the arrows
in the signatures as separating arguments. For example, the function `roll`
takes two integers as arguments and returns a list of integers. The square
brackets indicate lists. In the final line, we define the `rollAdv` function.

The Python functions are sourced from the Python file "foo.py" with the
following code:

[source, python]
----
import random

def roll(n, d):
    # Roll an n-sided die d times, return a list of results
    return [random.randint(1, d) for _ in range(n)]

def narrate(roll_value):
    return f"You rolled a {roll_value!s}"
----

Nothing about this code is particular to Morloc.

One of Morloc's core values is that foreign source code _never_ needs to know
anything about the Morloc ecosystem. Sourced code should always be nearly
idiomatic code that uses normal data types. The inputs and outputs of these
functions are natural Python integers, lists, and strings -- they are not
Morloc-specific serialized data or ad hoc textual formats.

This module is dependent on the `types` module, which in turn is dependent on
the `prelude` module. So before compiling, we need to import both of these:

[source, console]
----
morloc import prelude
morloc import types
----

Now we can compile and run this program as so:

[source, console]
----
$ morloc make main.loc
$ ./nexus rollAdv
"You rolled a 20"
----

As a random function, it will return a new result every time.

So, what's the point? We could have done this more easily in a pure Python
script. Morloc generates a CLI for us, type checks the program, and performs
some runtime validation (by default, just on the final inputs and outputs). But
there are other tools in the Python universe can achieve this same end. Where
Morloc is uniquely valuable is in the polyglot setting.

=== Polyglot dice rolling

In this next example, we rewrite the prior dice example with all three functions
being sourced from different languages:

[source, morloc]
----
module dnd (rollAdv)

import types

source R from "foo.R" ("roll")
source Cpp from "foo.hpp" ("max")
source Py from "foo.py" ("narrate")

roll :: Int -> Int -> [Int]
max :: [Int] -> Int
narrate :: Int -> Str

rollAdv = narrate (max (roll 2 20))
----

Note that all of this code is exactly the same as in the prior example except
the source statements.

The `roll` function is defined in R:

[source, r]
----
roll <- function(n, d){
    sample(1:d, n)
}
----

The `max` function is defined in {cpp}:

[source, c++]
----
#pragma one
#include <vector>
#include <algorithm>

template <typename A>
A max(const std::vector<A>& xs) {
    return *std::max_element(xs.begin(), xs.end());
}
----

The `narrate` function is defined in Python:

[source, python]
----
def narrate(roll_value):
    return f"You rolled a {roll_value!s}"
----

This can be compiled and run in exactly the same way as the prior monoglot
example. It will run a bit slower, mostly because of the heavy cost of starting
the R interpreter.

The Morloc compiler automatically generates all code required to translate data
between the languages. Exactly how this is done will be discussed later.

=== Parallelism example

Here is an example showing a parallel map function written in Python that calls {cpp} functions.

[source, morloc]
----
module m (sumOfSums)

import types

source Py from "foo.py" ("pmap")
source Cpp from "foo.hpp" ("sum")

pmap a b :: (a -> b) -> [a] -> [b]
sum :: [Real] -> Real

sumOfSums = sum . pmap sum
----

This Morloc script exports a function that sums a list of lists of real
numbers. Here we use the dot operator for function composition. The sum function
is implemented in {cpp}:

[source, c++]
----
// C++ header sourced by morloc script
#pragma one
#include <vector>

double sum(const std::vector<double>& vec) {
    double sum = 0.0;
    for (double value : vec) {
        sum += value;
    }
    return sum;
}
----

The parallel `pmap` function is written in Python:

[source, python]
----
# Python3 file sourced by morloc script
import multiprocessing as mp

def pmap(f, xs):
    with mp.Pool() as pool:
        results = pool.map(f, xs)
    return results
----

The inner summation jobs will be run in parallel. The `pmap` function has the
same signature as the non-parallel `map` function, so can serve as a drop-in
replacement.

This can be compiled and run with the lists being provided in JSON format:

[source, console]
----
$ morloc make main.loc
$ ./nexus sumOfSums '[[1,2],[3,4,5]]'
----
