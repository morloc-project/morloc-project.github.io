=== Module declarations

Every Morloc file is a module. A module declaration names the module and
optionally lists the terms it exports:

[source, morloc]
----
module mylib (foo, bar)
----

This declares a module named `mylib` that exports `foo` and `bar`. Only
exported terms are visible to other modules that import this one.

If a module exports everything it defines, you can use the wildcard form:

[source, morloc]
----
module mylib (*)
----

For submodules that exist only to be imported by a parent, you can omit the
name entirely:

[source, morloc]
----
module (*)
----

An anonymous module's name is inferred from its file path relative to the
importing module. For example, if `main.loc` imports `.utils`, the compiler
will resolve the module in `utils/main.loc` (or `utils.loc`) and assign it the
name `utils`.

=== Importing modules

Morloc distinguishes between two kinds of imports: *system* modules and *local*
modules.

==== System modules

System modules are installed packages that live in
`~/.local/share/morloc/lib/`. They are imported by name, without any prefix:

[source, morloc]
----
import root-py
import root-cpp
----

System modules are installed with `morloc install`:

[source, console]
----
$ morloc install root
$ morloc install root-py
----

==== Local modules

Local modules are files or directories within your own project. They are
imported with a dot (`.`) prefix to distinguish them from system modules:

[source, morloc]
----
import .utils (helper)
import .lib.math (square)
----

The dot prefix tells the compiler to look for the module relative to the
directory of the importing file, not in the system library.

==== Selective imports

Both system and local imports support selective imports. Without a selector, all
exported terms are brought into scope:

[source, morloc]
----
import root-py             -- import everything from root-py
import .mylib              -- import everything from local mylib
import .mylib (foo, bar)   -- import only foo and bar from local mylib
----

=== Module resolution

When you write `import .foo`, the compiler looks for the module relative to the
directory containing the current file. It checks two locations, in order:

1. A directory module: `foo/main.loc`
2. A file module: `foo.loc`

Dot-separated paths map to nested directories. For example, `import .lib.math`
resolves to either `lib/math/main.loc` or `lib/math.loc`.

Here is an example project layout:

----
project/
  main.loc            -- module main, imports .utils and .lib.math
  utils.loc           -- module (*), a flat file module
  utils.py
  lib/
    math/
      main.loc        -- module (*), a directory module
      main.py
----

The top-level `main.loc` imports both:

[source, morloc]
----
module main (negate_square, square_negate)

type Py => Real = "float"

import .utils (negate)
import .lib.math (square)

negate_square :: Real -> Real
negate_square x = negate (square x)

square_negate :: Real -> Real
square_negate x = square (negate x)
----

The flat file `utils.loc` exports `negate`:

[source, morloc]
----
module (*)

source Py from "utils.py" ("negate")

type Py => Real = "float"

negate :: Real -> Real
----

And the directory module `lib/math/main.loc` exports `square`:

[source, morloc]
----
module (*)

source Py from "main.py" ("square")

type Py => Real = "float"

square :: Real -> Real
----

Local modules can also import other local modules. The path is always relative
to the importing file. For example, if `bar/baz/main.loc` needs to import a
sibling at `bif/biz/`, it writes:

[source, morloc]
----
import .bif.biz (mul)
----

This resolves relative to `bar/baz/`, looking for `bar/baz/bif/biz/main.loc`.

=== Naming a local directory "root"

Since `root` is also the name of a system module, a local directory named
`root/` must be imported with the dot prefix to avoid ambiguity:

[source, morloc]
----
import root         -- imports the system "root" module
import .root        -- imports the local "root/" directory
----

The dot prefix always forces local resolution, so there is never a collision
between local and system module names.

