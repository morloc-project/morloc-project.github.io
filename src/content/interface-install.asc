=== Search and install

The docstrings are used for discoverability as well. In this section I'll cover
how modules are installed as executables or standard modules and how they can be
searched.

I'll demonstrate this with a simple two module Morloc program describing a set
of DnD operations. The first module defines general random operations:

[source,morloc]
.fate.loc
----
module fate (roll, coinToss, choose)

import root-py

source Py from "fate.py"
  ( "roll" as roll
  , "coin_toss" as coinToss  
  , "choose" as choose
  )

--' Roll n d-sided dice
roll :: 
  --' Number of dice
  Int ->
  --' Number of pips per die
  Int ->
  --' Roll values
  {[Int]}

--' Randomly return True or False
coinToss :: {Bool}

--' Randomly choose one element from a non-empty list
choose a :: [a] -> {a}
----

The sourced `fate.py` script contains the following code:

[source,python]
.fate.py
----
import random

def choose(xs):
    return random.choice(xs)

def roll(n, d):
    return [random.randint(1, d) for _ in range(n)] 

def coin_toss():
    return bool(random.randint(0,1))
----

We can install `fate` with `morloc install --build ./fate`. This create the
morloc module we will need in the future as well as an executable we can test.

We can test this, for example by rolling 3d8:

[source,console]
----
$ fate roll 3 8
[8,2,5]
----

Next let's build on this foundation. First let's make a simple tavern script
that helps generate new characters.

.tavern.loc
[source,morloc]
----
module tavern (randomClass, randomRace)

import root-py
import fate (choose) 

--' Select a random class
randomClass :: {Str}
randomClass = choose ["Fighter", "Wizard", "Rogue", "Cleric", "Ranger", "Bard"]

--' Select a random race
randomRace :: {Str}
randomRace = choose ["Human", "Elf", "Dwarf", "Halfling"]
----

Next let's add a module for combat:

.combat.loc
[source,morloc]
----
module combat (rollAdv, fighterDamage, threeHits, intro)

import root-py
import root-r
import fate (roll, coinToss) 

--' Roll a pair of d20 dice and keep the larger result
rollAdv :: {Int}
rollAdv = {fold max 0 !(roll 2 20)}

--' Damage done on hit, modifier + sum of dice rolls
damage ::
  --' Enemy Armor Class
  Int ->
  --' Attack modifier
  Int ->
  --' Attack dice
  {[Int]} ->
  --' Damage modifier
  Int ->
  --' Damage dice
  {[Int]} ->
  --' Total damage
  {Int}
damage ac atkMod atkDice dmgMod dmgDice = do
  let atk = atkMod + fold max 0 !atkDice
  let dmg = dmgMod + sum !dmgDice
  { ? atk >= ac = dmg : 0 }

--' Damage calculation for a fighter
fighterDamage ::
  --' Enemy Armor Class
  Int ->
  --' Fighter's damage
  {Int}
fighterDamage ac = damage ac 4 (roll 1 20) 2 (roll 2 8)

source R from "combat.R" ("intro")

--' Introduce a new battle!
intro ::
  --' Monster name
  --' literal: true
  Str ->
  --' DM's monster intro
  Str
----

We can build just the CLI tools if we wish: 

[source,bash]
----
$ morloc make --install combat.loc
----

This will build the executable `combat` which is a script that carries with it all
the information needed for execution. You can copy it anywhere you like on the
system and it will work (so long as the contents of the directory where it was
made are preserved). If you want, you can move the executable to a location in
your system PATH and then you can call it as a normal program from anywhere.

But Morloc offers a cleaner solution:

[source,bash]
----
$ morloc make --install combat.loc
----

This command does several things.

First it installs the `combat` executable to a standard path. The `pool/` artifacts
and all files in the current working directory need to be moved to a standard
location. There are two ways you can specify the required build files.

You can specify required files with `--include` arguments

[source,bash]
----
$ morloc make --install combat.loc --include fate.loc --include fate.py --include combat.R
----

Or you can create a `package.yaml` file and add an `include` field. The default
file can be generaed for you with `morloc new`. You can then modify the
`include` field list with the required files:

[source,yaml]
----
name: combat
version: 0.1.0
homepage: null
synopsis: null
description: null
category: null
license: MIT
author: null
maintainer: null
github: null
bug-reports: null
dependencies: []
# Files to include when installing with `morloc make --install`
include: ["fate.*", "combat.R"]
----

Then run `morloc make --install combat.loc`.

In both install paths, the `combat` source code is copied to the
`~/.local/share/morloc/exe/<modname>` folder and the executable script itself is
written to `~/.local/share/morloc/bin/`.

We can view the installed executable:

[source,console]
----
$ morloc list -v combat
Programs:
  combat  4 commands
    rollAdv :: Int
    fighterDamage :: Int -> Int
    threeHits :: Int -> [Int]
    intro :: Str -> Str
----

If we add the Morloc bin folder above to PATH, then we can now use this program naturally:

[source,console]
----
$ combat -h
Usage: morloc-nexus <manifest> [OPTION...] COMMAND [ARG...]

Nexus Options:
 -h, --help            Print this help message
 -o, --output-file     Print to this file instead of STDOUT
 -f, --output-format   Output format [json|mpk|voidstar]

Commands (call with -h/--help for more info):
  rollAdv        Roll a pair of d20 dice and keep the larger result
  fighterDamage  Damage calculation for a fighter
  threeHits      Three hit rolls against an enemy
  intro          Introduce a new battle!
$ combat fighterDamage 15
12
$ combat fighterDamage 15
8
----

We can also uninstall with `morloc uninstall combat`. This will cleanly remove the
installed source and the installed executable script.
