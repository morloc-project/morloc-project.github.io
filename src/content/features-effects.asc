=== Effects and delayed evaluation

Morloc is a functional programming language. Here a "function" is a mapping from
a value in one domain to value in another domain. This works neatly for pure
functions. But it becomes complicated when "effects", like interactions with the
operating system, are introduced.

Consider a simple `readFile` program:

[source,morloc]
----
readFile :: Filename -> Str
----

This Morloc program takes a filename as input and returns a string containing
the file contents. Logically, this is a function. You are mapping a filename to
the file contents. At a given slice of time on a given system, there is a
one-to-one mapping between filenames and files.

You can save the contents in a variable:

[source,morloc]
----
contents = readFile "myfile.txt"
----

`contents` is now a value storing a string. But the world is not constant. Files
change. Let's say that `myfile.txt` is a log file and we want to read it at
multiple time points. Further, we don't want to specify the filename every time
we call the function. It would be more convenient to partially apply the
filename and have a function that will map the applied filename to whatever is
currently at the file location. But partially applying the filename to
`readFile` results in a **value** not a **function**. In many familiar
languages, you can define functions that have no arguments. So you could call
`read_log()` and it would read the log and return a fresh contents blob every
time the function was executed.

Let's look at an even trickier problem. Suppose we wanted a function that
returns the current epoch time. How would this be defined in Morloc? You could
require arguments that transform the problem to a true function. The world state
could be an argument. This state might be the locale or some other
reference. The function then becomes

[source,morloc]
----
time :: TemporalState -> Time
----

But once again, when we partially apply the function, we again are reduced to a
value. Perhaps we want a "function" that always returns California time.

A second example is random numbers. We can define a family of random functions like so:

[source,morloc]
----
runif :: Real -> Real -> Real
choose a :: [a] -> a
coinToss :: ???
----

`runif` and `choose` are functions that produce random values when given the
required arguments. But what is `coinToss`? There are no arguments. Again, you
could reparameterize these random functions as pure functions that take a random
seed, or a stateful random generator, as an argument. That would look something
like this:

[source,morloc]
----
runif :: Real -> Real -> RNG -> (Real, RNG)
choose a :: [a] -> RNG -> (a, RNG)
coinToss :: RNG -> (Bool, RNG)
----

This is the "right" way to do random effects. But it is certainly not the most
common way of doing it. In most languages, the random number generator exists in
global state. Or the random number generator might use actual system noise to
get truly random values.

What we want in Morloc is to preserve the power of partial function application
but still have the ability to call "functions" with no arguments. We can achieve
this by preventing a term from being evaluated until we explicitly request
evaluation.

In Morloc, delayed computatoin is specified with braces at both the type-level
and the term-level. So you can write the (rather pointless) expression:

[source,morloc]
----
val :: {Int}
val = {42}
----

This defins an expression that evaluates to the value 42 whenever its value is
requested. There are two ways to request evaluation. First, the top value in an
program is implicitly forced. Here is `val` is directly exported in the compiled
program, the command `./nexus val` will return 42. The second way is to force
evaluation with `!val`.

Let's look at a less trivial cases:

[source,morloc]
----
time :: {Time}
timeStr = "The time right now is #{!time}"

readFile :: Filename -> {Str}
readMyLog = readFile "mylog.log"
logvalue1 = !readMyLog -- read the current log data
logvalue2 = !readMyLog -- read the log again

-- roll one d-sided dice
rollDie :: Int -> {Int}

roll1d20 = {Int}
roll1d20 = rollDie 20 

-- stores one pair of independent d20 rolls
roll2d20 = (Int, Int)
roll2d20 = (!roll1d20, !roll1d20)
----

Let's dig more into the final function. The roll2d20 initializes with two
rolls. It is fully evaluated. What if we want an expression that always
evaluates to a fresh pair of 2d20 rolls? For this we can wrap the expression in
braces.

[source,morloc]
----
roll2d20 = {(Int, Int)}
roll2d20 = {(!roll1d20, !roll1d20)}
----

The braces around the expression indicates that its evaluation is suspended
until forced. Once it is forced to evaluate, the inner rolls are forced as well,
leading to fresh dice rolls.

What if we have more complex sets of effects? Perhaps we have many rolls that
need to be used in conditionals. Let's say we want to simulate damage in a DnD
attack. If the attack d20 roll is greater than the enemy's defense, then the
attack hits and does damage equal to base damage plus the sum of the rolled
attack dice. We could write all this into a suspended expression:

[source,morloc]
----
damage :: Int -> Int -> {[Int]} -> {Int}
damage ac mod dmgDice = { ? !roll1d20 > ac = sum !dmgDice : 0 }
----

This works. But what if we add we add in terms that exist just for their side
effects. Suppose we are writing a shellscript-like sequence of commands. Maybe
we want to make a directory, move into the directory, create a file, and echo
something into it. Here we need to sequence effects.


[source,morloc]
----
--' Make a directory
mkdir :: Path -> {ExitCode}
cd :: Path -> {ExitCode}
touch :: Path -> {ExitCode}

scriptAttempt1 :: ExitCode
scriptAttempt1 =
  let _ = !(mkdir "foo/bar")
  let _ = !(cd "foo/bar")
  let e = !(touch "baz")
  in e
----

This works. The `let` syntax forces evaluation in a specific order and the `let`
wildcard allows results to be ignored (though here, we should probably not be
ignoring the exit code).

Morloc also has a `do` syntax that allows a more imperative approach:

[source,morloc]
----
scriptAttempt1 :: {ExitCode}
scriptAttempt1 = do
  mkdir "foo/bar"
  cd "foo/bar"
  touch "baz"
----

Note that the expression type is delayed, so we can control when this
computation is evaluated.

Here is one last example that shows several ways to implement the same problem

[source,morloc]
----
rollAdv :: {Int}
rollAdv = {max !roll1d20 !roll1d20}

rollAdv'' :: {Int}
rollAdv'' =
  let x = !roll1d20
  let y = !roll1d20
  in {max x y}

rollAdv' :: {Int}
rollAdv' = do
  x <- roll1d20
  y <- roll1d20
  max x y
----
