=== Overload terms with typeclasses

In addition to term polymorphism, Morloc offers more traditional ad hoc
polymorphism over types. Here typeclasses may be defined and type-specific
instances may be given. This idea is similar to typeclasses in Haskell, traits
in Rust, interfaces in Java, and concepts in {cpp}.

In the example below, `Addable` and `Foldable` classes are defined and used to
create a polymorphic `sum` function.

[source, morloc]
----
class Addable a where
    zero a :: a
    add a :: a -> a -> a

instance Addable Int where
    source Py from "arithmetic.py" ("add" as add)
    source Cpp from "arithmetic.hpp" ("add" as add)
    zero = 0

instance Addable Real where
    source Py from "arithmetic.py" ("add" as add)
    source Cpp from "arithmetic.hpp" ("add" as add)
    zero = 0.0

class Foldable f where
    foldr a b :: (a -> b -> b) -> b -> f a -> b

instance Foldable List where
    source Py from "foldable.py" ("foldr" as foldr)
    source Cpp from "foldable.hpp" ("foldr" as foldr)

sum = foldr add zero
----

The instances may import implementations for many languages.

The native functions may themselves be polymorphic, so the imported
implementations may be repeated across many instances. For example, the Python
`add` may be written as:

[source,python]
----
def add(x, y):
    return x + y
----

And the {cpp} add as:

[source,cpp]
----
template <class A>
A add(A x, A y){
    return x + y;
}
----

Typeclasses may be imported from other modules. For example, a module that
defines the `Ord` typeclass and derived operators can be imported and
instantiated in another module:

[source, morloc]
----
import numops (Ord, (<), (>), (>=), min)

instance Ord Int where
    source Py from "foo.py" ("le" as (<=))
----

// === Ad hoc polymorphism (overloading and type classes)
//
// Morloc supports ad hoc polymorphism, where instances of a function may be
// defined for multiple types.
//
// Here is an example of a simple type classe, `Sizeable`, which represents objects
// that have be mapped to an integer that conveys the notion of size:
//
// [source, morloc]
// ----
// module size (add)
//
// class Sizeable a where
//   size a :: a -> Int
// ----
//
// Instances of `Sizeable` may be defined in this module or in modules that import
// this module. For example:
//
// [source, morloc]
// ----
// module foo *
//
// type Cpp => List a = "std::vector<$1>" a
// type Py => List a = "list" a
//
// type Cpp => Str = "std::string"
// type Py => Str = "str"
//
// instance Sizeable [a] where
//   source Cpp "foo.hpp" ("size" as size)
//   source Py ("len" as size)
//
// instance Sizeable Str where
//   source Cpp "foo.hpp" ("size" as size)
//   source Py ("len" as size)
// ----
//
// Where in {cpp}, the generic function `size` returns length for any {cpp} size
// with a `size` method. For Python, the builtin `len` can be directly used.
//
// Morloc also supports multiple parameter typeclasses, such as in the `Packable`
// typeclass below:
//
// [source, morloc]
// ----
// class Packable a b where
//   pack a b :: a -> b
//   unpack a b :: b -> a
// ----
//
// This specific typeclass is special in the Morloc ecosystem since it handles
// the simplification of complex types before serialization. Instances may overlap
// and the most specific one will be selected. `Packable` may have instances such
// as the following:
//
// [source, morloc]
// ----
// instance Packable [a] (Queue a) where
//   ...
//
// instance Packable [a] (Set a) where
//   ...
//
// instance Packable [(a,b)] (Map a b) where
//   ...
//
// instance Packable [(Int,b)] (Map Int b) where
//   ...
// ----




