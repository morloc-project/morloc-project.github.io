=== Source function from foreign languages

In Morloc, you can import functions from many languages and compose them under
a common type system. The syntax for importing functions from source files is as
follows:

[source, morloc]
----
source Cpp from "foo.hpp" ("map", "sum", "snd")
source Py from "foo.py" ("map", "sum", "snd")
----

This brings the functions `map`, `sum`, and `snd` into scope in the Morloc
script. Each of these functions must be defined in the {cpp} and Python
scripts. For Python, since `map` and `sum` are builtins, only `snd` needs to be
defined. So the `foo.py` function only requires the following two lines:

[source, python]
----
def snd(pair):
    return pair
----

The {cpp} file, `foo.hpp`, may be implemented as a simple header file with generic
implementations of the three required functions.

[source, c++]
----
#pragma once
#include <vector>
#include <tuple>

// map :: (a -> b) -> [a] -> [b]
template <typename A, typename B, typename F>
std::vector<B> map(F f, const std::vector<A>& xs) {
    std::vector<B> result;
    result.reserve(xs.size());
    for (const auto& x : xs) {
        result.push_back(f(x));
    }
    return result;
}

// snd :: (a, b) -> b
template <typename A, typename B>
B snd(const std::tuple<A, B>& p) {
    return std::get<1>(p);
}

// sum :: [a] -> a
template <typename A>
A sum(const std::vector<A>& xs) {
    A total = A{0};
    for (const auto& x : xs) {
        total += x;
    }
    return total;
}
----

Note that these implementations are completely independent of Morloc -- they
have no special constraints, they operate on perfectly normal native data
structures, and their usage is not limited to the Morloc ecosystem. The
Morloc compiler is responsible for mapping data between the languages. But to
do this, Morloc needs a little information about the function types. This is
provided by the general type signatures, like so:

[source, morloc]
----
map a b :: (a -> b) -> [a] -> [b]
snd a b :: (a, b) -> b
sum :: [Real] -> Real
----

The syntax for these type signatures is inspired by Haskell, with the exception
that generic terms (`a` and `b` here) must be declared on the left. Square
brackets represent homogenous lists and parenthesized, comma-separated values
represent tuples, and arrows represent functions. In the `map` type, `(a -> b)`
is a function from generic value `a` to generic value `b`;  `[a]` is the input
list of initial values; `[b]` is the output list of transformed values.

Removing the syntactic sugar for lists and tuples, the signatures may be written
as:

[source, morloc]
----
map a b :: (a -> b) -> List a -> List b
snd a b :: Tuple2 a b -> b
sum :: List Real -> Real
----

These signatures provide the _general types_ of the functions. But one general
type may map to multiple _native_, language-specific types. So we need to
provide an explicit mapping from general to native types.

[source, morloc]
----
type Cpp => List a = "std::vector<$1>" a
type Cpp => Tuple2 a b = "std::tuple<$1,$2>" a b
type Cpp => Real = "double"
type Py => List a = "list" a
type Py => Tuple2 a b = "tuple" a b
type Py => Real = "float"
----

These type functions guide the synthesis of native types from general
types. Take the {cpp} mapping for `List a` as an example. The basic {cpp} list type
is `vector` from the standard template library. After the Morloc typechecker
has solved for the type of the generic parameter `a`, and recursively converted
it to {cpp}, its type will be substituted for `$1`. So if `a` is inferred to be
a `Real`, it will map to the {cpp} `double`, and then be substituted into the list
type yielding `std::vector<double>`. This type will be used in the generated {cpp}
code.



