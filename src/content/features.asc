    
=== Basic data types

Here we'll cover the basic Morloc data types that directly map to Morloc
binary. For these types, there are fairly direct representations in most
languages. The basic types are listed below:

[cols="2, 1, 2, 1"]
|===
| Type | Domain | Schema | Width (bytes)

| Unit | `()` | z | 1
| Bool | `True` \| `False` | b | 1
| UInt8 | latexmath:[[0,2^{8})] | u1 | 1
| UInt16 | latexmath:[[0,2^{16})] | u2 | 2
| UInt32 | latexmath:[[0,2^{32})] | u4 | 4
| UInt64 | latexmath:[[0,2^{64})] | u8 | 8
| Int8 | latexmath:[[-2^{7},2^{7})] | i1 | 1
| Int16 | latexmath:[[-2^{15},2^{15})] | i2 | 2
| Int32 | latexmath:[[-2^{31},2^{31})] | i4 | 3
| Int64 | latexmath:[[-2^{63},2^{63})] | i8 | 4
| Float32 | IEEE float | f4 | 4
| Float64 | IEEE double | f8 | 8
| List x | het lists | a{x} | latexmath:[16 + n \Vert a \Vert ]
| Tuple2 x1 x2 | 2-ples | t2{x1}{x2} | latexmath:[\Vert a \Vert + \Vert b \Vert]
| TupleX latexmath:[\ t_i\ ...\ t_k] | k-ples | latexmath:[tkt_1\ ...\ t_k] | latexmath:[\sum_i^k \Vert t_i \Vert]
| latexmath:[\{ f_1 :: t_1,\ ... \ , f_k :: t_k \}] | records | latexmath:[mk \Vert f_1 \Vert f_1 t_1\ ...\ \Vert f_k \Vert f_k t_k ] | latexmath:[\sum_i^k \Vert t_i \Vert]
|===

All basic types may be written to a schema that is used internally to direct
conversions between Morloc binary and native basic types. The schema values
are shown in the table above. For example, the type `[(Bool, [Int8])]` would
have the schema `at2bai1`. You will not usually have to worry about these
schemas, since they are mostly used internally. They are worth knowing, though,
since they appear in low-level tests, generated source code, and binary data
packets.

A `record` is a named, heterogenous list such as a `struct` in C, a `dict` in
Python, or a `list` in R. The type of the record exactly describes the data
stored in the record (in contrast to parameterized types like `[a]` or `Map a
b`). They are represented in Morloc binary as tuples, the keys are only stored
in the schemas.

A `table` is like a record where field types represent the column types. But
`table` is not just syntactic sugar for a record of lists, the `table`
annotation is passed with the record through the compiler all the way to the
translator, where the language-specific serialization functions may have special
handling for tables.

Both are defined in similar ways.

[source, morloc]
----
record (PersonRec a) = PersonRec {name :: Str, age :: Int}
record Cpp => PersonRec a = "MyObj"

table (PersonTbl a) = PersonObj {name :: Str, age :: Int}
table R => PersonTbl a = "data.frame"
table Cpp => PersonTbl a = "struct"
----

=== Functions

Function definition follows Haskell syntax.

[source, morloc]
----
foo x = g (f x)
----

Morloc supports the `.` operator for composition, so we can re-write `foo` as:

[source, morloc]
----
foo = g . f
----

Morloc supports partial application of arguments.

For example, to multiply every element in a list by 2, we can write:

[source, morloc]
----
multiplyByTwo = map (mul 2.0)
----

=== One term may have many definitions

Morloc supports a kind of _language_ or _implementation_ polymorphism. Each
term may have many definitions. For example, the function `mean` has three
definitions below:

[source, morloc]
----
import base (sum, div, size, fold, add)
import types
source Cpp from "mean.hpp" ("mean")
mean :: [Real] -> Real
mean xs = div (sum xs) (size xs)
mean xs = div (fold 0 add xs) (size xs)
----

`mean` is sourced directly from {cpp}, it is defined in terms of the `sum`
function, and it is defined more generally with `sum` written as a fold
operation. The Morloc compiler is responsible for deciding which
implementation to use.

The equals operator in Morloc indicates functional substitutability. When you
say a term is "equal" to something, you are giving the compiler an option for
what may be substituted for the term. The function `mean`, for example, has many
functionally equivalent definitions. They may be in different languages, or they
may be more optimal in different situations.

Now this ability to simply state that two things are the same can be abused. The
following statement is syntactically allowed in Morloc:

[source, morloc]
----
x = 1
x = 2
----

What is `x` after this code is run? It is 1 _or_ 2. The latter definition does
not mask the former, it _appends_ the former. Now in this case, the two values
are certainly not substitutable. Morloc has a simple _value checker_ that will
catch this type of primitive contradition. However, the value checker cannot yet
catch more nuanced errors, such as:

[source, morloc]
----
x = div 1 (add 1 1)
x = div 2 1
----

In this case, the type checker cannot check whithin the implementation of `add`,
so it cannot know that there is a contradiction. For this reason, some care is
needed in making these definitions.


=== Passing types between languages

Up to now we have ignored the method Morloc uses to allow communication
between languages. We've simply asserted that there was a "common type
system". We'll now give a quick peak into how all this works (finer details will
be reserved for technical sections later on).

Every Morloc general type maps unambiguously to a binary form that consists of
several fixed-width literal types, a list container, and a tuple container. The
literal types include a unit type, a boolean, signed integers (8, 16, 32, and 64
bit), unsigned integers (8, 16, 32, and 64 bit), and IEEE floats (32 and 64 bit). The
list container is represented by a 64-bit size integer and a pointer to an
unboxed vector. The tuple is represented as a set of values in contiguous
memory.

Here is an example of how the type `([UInt8], Bool)`, with the value `([3,4,5],True)`,  might be laid out in memory:

[source]
---
03 00 00 00 00 00 00 00 00 -- first tuple element, specifies list length (little-endian)
30 00 00 00 00 00 00 00 00 -- first tuple element, pointer to list
01 00 00 00 00 00 00 00 00 -- second tuple element, with 0-padding
03 04 05                   -- 8-bit values of 3, 4, and 5
---

Records are represented as tuples. The names for each field are stored only in
the type schemas. Morloc also supports tables, which are just records where
the field types correspond to the column types and where fields are all
equal-length lists. Records and tables may be defined as shown below:

[source, morloc]
----
record Person = Person { name :: Str, age :: UInt8 }
table People = People { name :: Str, age :: Int }

alice = { name = "Alice", age = 27 }
students = { name = ["Alice", "Bob"], age = [27, 25] }
----

The Morloc type signatures can be translated to schema strings that may be
parsed by a foundational Morloc C library into a type structure. Every
supported language in the Morloc ecosystem must provide a library that wraps
this Morloc C library and translates to/from Morloc binary given the
Morloc type schema.

By itself, this system allows any type that is comprised entirely of literals,
lists, and tuples to be translated between languages. But what about types that
do not break down cleanly into these forms? For example, consider the
parameterized `Map k v` type that represents a collection with keys of generic
type `k` and values of generic type `v`. This type may have many
representations, including a list of pairs, a pair of columns, a binary tree,
and a hashmap. In order for Morloc to know how to convert all `Map` types in
all languages to one form, it must know how to express `Map` type in terms of
more primitive types. The user can provide this information by defining
instances of the `Packable` typeclass for `Map`. This typeclass defines two
functions, `pack` and `unpack`, that construct and deconstruct a complex type.

[source, morloc]
----
class Packable a b where
    pack a b :: a -> b
    unpack a b :: b -> a
----

The `Map` type for Python and {cpp} may be defined as follows:

[source, morloc]
----
type Py => Map key val = "dict" key val
type Cpp => Map key val = "std::map<$1,$2>" key val
instance Packable ([a],[b]) (Map a b) where
    source Cpp from "map-packing.hpp" ("pack", "unpack")
    source Py from "map-packing.py" ("pack", "unpack")
----

The Morloc user never needs to directly apply the `pack` and `unpack`
functions. Rather, these are used by the compiler within the generated code. The
compiler constructs a serialization tree from the general type and from this
trees generates the native code needed to (un)pack types recursively until only
primitive types remain. These may then be directly translated to Morloc binary
using the language-specific binding libraries.

In some cases, the native type may not be as generic as the general type. Or you
may want to add specialized (un)packers. In such cases, you can define more
specialized instances of `Packable`. For example, if the `R` `Map` type is
defined as an `R` list, then keys can only be strings. Any other type should
raise an error. So we can write:

[source, morloc]
----
type R => Map key val = "list" key val
instance Packable ([Str],[b]) (Map Str b) where
source R from "map-packing.R" ("pack", "unpack")
----

Now whenever the key generic type of `Map` is inferred to be anything other than
a string, all R implementations will be pruned.


=== Compose functions across languages

In Morloc, you can import functions from many languages and compose them under
a common type system. The syntax for importing functions from source files is as
follows:

[source, morloc]
----
source Cpp from "foo.hpp" ("map", "sum", "snd")
source Py from "foo.py" ("map", "sum", "snd")
----

This brings the functions `map`, `sum`, and `snd` into scope in the Morloc
script. Each of these functions must be defined in the {cpp} and Python
scripts. For Python, since `map` and `sum` are builtins, only `snd` needs to be
defined. So the `foo.py` function only requires the following two lines:

[source,python]
----
def snd(pair):
    return pair
----

The {cpp} file, `foo.hpp`, may be implemented as a simple header file with generic
implementations of the three required functions.

[source,C++]
----
#pragma once
#include <vector>
#include <tuple>

// map :: (a -> b) -> [a] -> [b]
template <typename A, typename B, typename F>
std::vector<B> map(F f, const std::vector<A>& xs) {
    std::vector<B> result;
    result.reserve(xs.size());
    for (const auto& x : xs) {
        result.push_back(f(x));
    }
    return result;
}

// snd :: (a, b) -> b
template <typename A, typename B>
B snd(const std::tuple<A, B>& p) {
    return std::get<1>(p);
}

// sum :: [a] -> a
template <typename A>
A sum(const std::vector<A>& xs) {
    A total = A{0};
    for (const auto& x : xs) {
        total += x;
    }
    return total;
}
----

Note that these implementations are completely independent of Morloc -- they
have no special constraints, they operate on perfectly normal native data
structures, and their usage is not limited to the Morloc ecosystem. The
Morloc compiler is responsible for mapping data between the languages. But to
do this, Morloc needs a little information about the function types. This is
provided by the general type signatures, like so:

[source, morloc]
----
map a b :: (a -> b) -> [a] -> [b]
snd a b :: (a, b) -> b
sum :: [Real] -> Real
----

The syntax for these type signatures is inspired by Haskell, with the exception
that generic terms (`a` and `b` here) must be declared on the left. Square
brackets represent homogenous lists and parenthesized, comma-separated values
represent tuples, and arrows represent functions. In the `map` type, `(a -> b)`
is a function from generic value `a` to generic value `b`;  `[a]` is the input
list of initial values; `[b]` is the output list of transformed values. 

Removing the syntactic sugar for lists and tuples, the signatures may be written
as:

[source, morloc]
----
map a b :: (a -> b) -> List a -> List b
snd a b :: Tuple2 a b -> b
sum :: List Real -> Real
----

These signatures provide the _general types_ of the functions. But one general
type may map to multiple _native_, language-specific types. So we need to
provide an explicit mapping from general to native types.

[source, morloc]
----
type Cpp => List a = "std::vector<$1>" a
type Cpp => Tuple2 a b = "std::tuple<$1,$2>" a b
type Cpp => Real = "double"
type Py => List a = "list" a
type Py => Tuple2 a b = "tuple" a b
type Py => Real = "float"
----

These type functions guide the synthesis of native types from general
types. Take the {cpp} mapping for `List a` as an example. The basic {cpp} list type
is `vector` from the standard template library. After the Morloc typechecker
has solved for the type of the generic parameter `a`, and recursively converted
it to {cpp}, its type will be substituted for `$1`. So if `a` is inferred to be
a `Real`, it will map to the {cpp} `double`, and then be substituted into the list
type yielding `std::vector<double>`. This type will be used in the generated {cpp}
code.

Morloc functions may be defined:

[source, morloc]
----
sumSnd xs = sum (map snd xs)
----

These Morloc functions will be internally rewritten in terms of the native
imported functions, for example:

[source, morloc]
----
\xs -> sum (map snd xs)
----

So in the final form, all functions in Morloc are imported from foreign languages.

Morloc also supports partial application, eta reduction, and the dot-operator
for composition. So `sumSnd` can be simplified to:

[source, morloc]
----
sumSnd = sum . map snd
----

Remember, we imported each of these functions in both Python _and_ {cpp}, so
which functions are used in the generated code? This problem is addressed in the
next section.

=== Overload terms with typeclasses

In addition to language polymorphism, Morloc offers more traditional ad hoc
polymorphism over types. Here typeclasses may be defined and type-specific
instances may be given. This idea is similar to typeclasses in Haskell, traits
in Rust, interfaces in Java, and concepts in {cpp}.

In the example below, `Addable` and `Foldable` classes are defined and used to
create a polymorphic `sum` function.

[source, morloc]
----
class Addable a where
    zero a :: a
    add a :: a -> a -> a

instance Addable Int where
    source Py "arithmetic.py" ("add")
    source Cpp "arithmetic.hpp" ("add")
    zero = 0

instance Addable Real where
    source Py "arithmetic.py" ("add")
    source Cpp "arithmetic.hpp" ("add")
    zero = 0.0

class Foldable f where
    foldr a b :: (a -> b -> b) -> b -> f a -> b

instance Foldable List where
    source Py "foldable.py" ("foldr")
    source Cpp "foldable.hpp" ("foldr")

sum = foldr add zero
----

The instances may import implementations for many languages.

The native functions may themselves be polymorphic, so the imported
implementations may be repeated across many instances. For example, the Python
`add` may be written as:

[source,python]
----
def add(x, y):
    return x + y
----

And the {cpp} add as:

[source,cpp]
----
template <class A>
A add(A x, A y){
    return x + y;
}
----




=== Type signatures and type functions

General type declarations also follow Haskell syntax:

[source, morloc]
----
take a :: Int -> List a -> List a
----

Where `a` is a generic type variable. Morloc supports `[a]` as sugar for `List a`.

The general types may be translated to concrete types by fully evaluating them
with a set of language-specific type functions. For example:


[source, morloc]
----
type Cpp => Int = "int"
type Py => Int = "int"

type Cpp => List a = "std::vector<$1>" a
type Py => List a = "list" a
----

Language-specific types are always quoted since they may contain syntax that is
illegal in the Morloc language.

Type functions may also map between general types.

[source, morloc]
----
type (Pairlist a b) = [(a,b)]
----

Why do I call them type functions, rather than just aliases? There is a lot more
that can be done with these functions that I am just beginning to explore.


=== Sourcing functions

Sourcing a function from a foreign language is done as follows:

[source,haskell]
----
source Cpp from "foo.h" ("mlc_foo" as foo) 

foo :: A -> B
----

Here we state that we are importing the function `mlc_foo` from the {cpp} source
file `foo.h` and calling it `foo`. We then give it a general type signature.

Currently Morloc treats language-specific functions as black boxes. The
compiler does not parse the {cpp} code to insure the type the programmer wrote
is correct. Checking a Morloc general type for a function against the source
code may often be possible with conventional static analysis. LLMs are also
quite effective at both inferring Morloc types from source code and checking
types against source code.

For statically typed languages like {cpp}, incorrectly typed functions will
usually be caught by the foreign language compiler.


=== Modules

A module includes all the code defined under the `import <module_name>`
statement. It can be imported with the `import` command.

The following module defines the constant `x` and exports it.

[source, morloc]
----
module foo (x)
x = 42
----

Another module can import `Foo`:

[source]
----
import Foo (x)

...
----

A term may be imported from multiple modules. For example: 

[source, morloc]
----
module main (add)
import cppbase (add)
import pybase (add)
import rbase (add)
----

This module imports that {cpp}, Python, and R `add` functions and exports all
of them. Modules that import `add` will import three different versions of the
function. The compiler will choose which to use.

=== Ad hoc polymorphism (overloading and type classes)

Morloc supports ad hoc polymorphism, where instances of a function may be
defined for multiple types.

Here is an example of a simple type classe, `Sizeable`, which represents objects
that have be mapped to an integer that conveys the notion of size:

[source, morloc]
----
module size (add)

class Sizeable a where
  size a :: a -> Int
----

Instances of `Sizeable` may be defined in this module or in modules that import
this module. For example:

[source, morloc]
----
module foo *

type Cpp => List a = "std::vector<$1>" a 
type Py => List a = "list" a 

type Cpp => Str = "std::string" 
type Py => Str = "str" 

instance Sizeable [a] where
  source Cpp "foo.hpp" ("size" as size)
  source Py ("len" as size)

instance Sizeable Str where
  source Cpp "foo.hpp" ("size" as size)
  source Py ("len" as size)
----

Where in {cpp}, the generic function `size` returns length for any {cpp} size
with a `size` method. For Python, the builtin `len` can be directly used.

Morloc also supports multiple parameter typeclasses, such as in the `Packable`
typeclass below:

[source, morloc]
----
class Packable a b where
  pack a b :: a -> b
  unpack a b :: b -> a
----

This specific typeclass is special in the Morloc ecosystem since it handles
the simplification of complex types before serialization. Instances may overlap
and the most specific one will be selected. `Packable` may have instances such
as the following:

[source, morloc]
----
instance Packable [a] (Queue a) where
  ...

instance Packable [a] (Set a) where
  ...

instance Packable [(a,b)] (Map a b) where
  ...

instance Packable [(Int,b)] (Map Int b) where
  ...
----


=== Core libraries

Each supported language has a base library that roughly corresponds to the
Haskell prelude. They have functions for mapping over lists, working with
strings, etc. They also contain standard type aliases for each language. For
example, `type Cpp => Int = "std::string"`.

The root of the current library is the `conventions` module that defines the
core type classes and the type signatures for the core functions. The
`conventions` library does not, however, load any foreign source code, so it is
entirely language agnostic.

Next each language has their own base module -- such as `pybase`, `rbase`, and
`cppbase` -- that import `conventions` and include the implementations for all
(or some) of the defined functions and typeclasses.

Finally, a `base` module imports all of the language-specific bases. Currently,
there are only three supported languages, so importing all their base modules is
not impractical. In the future, more selective approaches may be used.
