// Here we import a function named `mlc_foo` in the {cpp} source
// file `foo.h` and we give it the Morloc name `foo`. The function name in the
// foreign language may not be legal in Morloc, so quotations are
// required.
//
// All sourced functions require a type signature that describes their _general
// type_. This is required for type checking and downstream code generation.
//
// Currently Morloc treats language-specific functions as black boxes. The compiler
// does not parse the {cpp} code to insure the type the programmer wrote is
// correct. Checking a Morloc general type for a function against the source code
// may be possible with conventional static analysis. LLMs are also effective at
// both inferring Morloc types from source code and checking types against source
// code.
//
// For statically typed languages like {cpp}, incorrectly typed functions should be
// caught by the foreign language compiler. Also, when data is passed between
// languages, loaded into Morloc, or written, it is checked against the expected
// type schemas at runtime.

=== General data types

Morloc supports standard primitives, homogenous lists, and tuples.

.Booleans

Booleans in Morloc are represented as `True` or `False` under the `Bool` type.

.Numbers

Numbers may be represented in normal format, scientific notation, or as
hexidecimal/octal/binary format:

[source, morloc]
----
-- standard notation for integers and floats
42
4.2

-- scientific notation (upper or lowercase 'e')
4.2E16
4.2e16
4.2e-8

-- hexadecimal notation (case insensitive)
0xf00d
0xDEADBEAF 

-- octal notation (upper or lowercase 'o')
0o755

-- binary notation (upper or lowercase 'b')
0b0101
----

.Strings

Morloc supports multi-line strings and string interpolation.

String interpolation uses the `#{...}` syntax. The expression inside the braces
must evaluate to a `Str`:

[source, morloc]
----
helloYou you = "hello #{you}"
----

String interpolation works with any expression that returns a string.

Multi-line strings use triple quotes. Leading indentation common to all lines is
stripped:

[source, morloc]
----
longString =
  """
  this is a long
  string
  """

-- single-quote triple-strings also work
anotherString = '''single quotes are also OK'''

-- triple-quoted strings can contain internal quotes
quoted = """you can use "internal quotes" freely"""
----

.Tuples

Tuples may be used to store a fixed number of terms of different type.

[source, morloc]
----
x = (1, True, 6.45)
----

.Records

Records are essentially named tuples. Record type definitions and
language-specific handling will be addressed later, but record data is expressed
as shown in the example below:

[source, morloc]
----
{ name = "Alice", age = 42 }
----

.Lists

Lists are used to store a variable number of terms of the same type.

[source, morloc]
----
x = [1,2,3]
----

Lists do not yet have special accessors (e.g., slicing). List operations are
performed through sourced functions such as `head`, `tail`, `take`, etc. You may
import many of these from the `root` modules.

=== Pattern functions for data access/update

Data structures may be accessed and modified using pattern functions. These
patterns may be _getters_ that extract a tuple of values from a data structure
or _setters_ that update a data structure without changing its type.

.getters patterns

A *getter* pattern describes an optionally branching path into a data
structure. Each segment of the path may be a tuple index, a record key, or a
group of indices/keys. The terminal positions in the pattern are returned as
elements in a tuple. Here are a few examples:

[source, morloc]
----
-- return the 1st element in a tuple of any size
.0 (1,2) -- return 1
.0 ((1,3),2,5) -- return (1,3)

-- return the 2nd element in the first element of a tuple
.0.1 ((1,3),2,5) -- return 3 

-- returns the 2nd and 1st elements in a tuple
.(.1,.0) (1,2,3) -- returns (2,1)
.(.1,.0) (1,2)   -- returns (2,1)

-- indices and keys may be used together
.0.(.x, .y.1) ({x=1, y=(1,2), z=3}, 6) -- returns (1,2)
----

These patterns are transformed into functions may be used exactly like any other
function.

[source, morloc]
----
map .1 [(1,2),(2,3)] -- returns [2,3]
----

.setters patterns

Setter patterns are similar but add an assignment statement to each pattern
terminus.

[source, morloc]
----
.(.0 = 99) (1,2) -- return (99,2)

-- indices and keys may be used together
.0.(.x=99, .y.1=33) ({x=1, y=(1,2), z=3}, 6) -- returns ({x=99, y=(1,33), z=3}, 6)
----

.Comparison of patterns to Python syntax
[cols="2, 2, 3"]
|===
| Pattern                 | Python                   | Note
                          
| .0                      | lambda x: x[0]           | patterns are functions
| .0 x                    | x[0]                     |
| .0.k x                  | x[0]["k"]                |
| .(.1,.0) x              | (x[1], x[0])             |
| foo .0 xs               | foo(lambda x: x[0], xs)  | higher order
| .(.k = 1) x             | x["k"] = 1               |
|===

Note that setters are designed to not mutate data. The *spine* of the data
structure will be copied which retains links to the original data for unmodified
fields. So the expression `.(.0 = 42) x` when translated into Python will create
a new tuple with the first field being 42 and the remaining fields assigned to
elements of the original field. The same goes for records.

=== Source function from foreign languages

In Morloc, you can import functions from many languages and compose them under
a common type system. The syntax for importing functions from source files is as
follows:

[source, morloc]
----
source Cpp from "foo.hpp" ("map", "sum", "snd")
source Py from "foo.py" ("map", "sum", "snd")
----

This brings the functions `map`, `sum`, and `snd` into scope in the Morloc
script. Each of these functions must be defined in the {cpp} and Python
scripts. For Python, since `map` and `sum` are builtins, only `snd` needs to be
defined. So the `foo.py` function only requires the following two lines:

[source, python]
----
def snd(pair):
    return pair
----

The {cpp} file, `foo.hpp`, may be implemented as a simple header file with generic
implementations of the three required functions.

[source, c++]
----
#pragma once
#include <vector>
#include <tuple>

// map :: (a -> b) -> [a] -> [b]
template <typename A, typename B, typename F>
std::vector<B> map(F f, const std::vector<A>& xs) {
    std::vector<B> result;
    result.reserve(xs.size());
    for (const auto& x : xs) {
        result.push_back(f(x));
    }
    return result;
}

// snd :: (a, b) -> b
template <typename A, typename B>
B snd(const std::tuple<A, B>& p) {
    return std::get<1>(p);
}

// sum :: [a] -> a
template <typename A>
A sum(const std::vector<A>& xs) {
    A total = A{0};
    for (const auto& x : xs) {
        total += x;
    }
    return total;
}
----

Note that these implementations are completely independent of Morloc -- they
have no special constraints, they operate on perfectly normal native data
structures, and their usage is not limited to the Morloc ecosystem. The
Morloc compiler is responsible for mapping data between the languages. But to
do this, Morloc needs a little information about the function types. This is
provided by the general type signatures, like so:

[source, morloc]
----
map a b :: (a -> b) -> [a] -> [b]
snd a b :: (a, b) -> b
sum :: [Real] -> Real
----

The syntax for these type signatures is inspired by Haskell, with the exception
that generic terms (`a` and `b` here) must be declared on the left. Square
brackets represent homogenous lists and parenthesized, comma-separated values
represent tuples, and arrows represent functions. In the `map` type, `(a -> b)`
is a function from generic value `a` to generic value `b`;  `[a]` is the input
list of initial values; `[b]` is the output list of transformed values.

Removing the syntactic sugar for lists and tuples, the signatures may be written
as:

[source, morloc]
----
map a b :: (a -> b) -> List a -> List b
snd a b :: Tuple2 a b -> b
sum :: List Real -> Real
----

These signatures provide the _general types_ of the functions. But one general
type may map to multiple _native_, language-specific types. So we need to
provide an explicit mapping from general to native types.

[source, morloc]
----
type Cpp => List a = "std::vector<$1>" a
type Cpp => Tuple2 a b = "std::tuple<$1,$2>" a b
type Cpp => Real = "double"
type Py => List a = "list" a
type Py => Tuple2 a b = "tuple" a b
type Py => Real = "float"
----

These type functions guide the synthesis of native types from general
types. Take the {cpp} mapping for `List a` as an example. The basic {cpp} list type
is `vector` from the standard template library. After the Morloc typechecker
has solved for the type of the generic parameter `a`, and recursively converted
it to {cpp}, its type will be substituted for `$1`. So if `a` is inferred to be
a `Real`, it will map to the {cpp} `double`, and then be substituted into the list
type yielding `std::vector<double>`. This type will be used in the generated {cpp}
code.



=== Functions

Functions are defined with arguments seperated by whitespace:

[source, morloc]
----
foo x = g (f x)
----

Here `foo` is the Morloc function name and `x` is its first argument.

The Morloc `internal` module, which is imported into all `root` modules, defines
the composition (`.`) and application (`$`) operators.

With `.` , we can re-write `foo` as:

[source, morloc]
----
foo = g . f
----

Composition chains can build multi-stage pipelines:

[source, morloc]
----
process = format . transform . validate . parse
----

The `$` operator is the application operator. It has the lowest precedence, so
it can be used to avoid parentheses:

[source, morloc]
----
-- these are equivalent
foo (bar (baz x))
foo $ bar $ baz x
----

Morloc supports partial application of arguments.

For example, to multiply every element in a list by 2, we can write:

[source, morloc]
----
multiplyByTwo = map (mul 2)
----

Partial application works well for leading arguments, but what if we want to
partially apply a later argument?

For example, we can use direct partial application with subtraction to create
functions that subtract the input argument from a given value:

[source, morloc]
----
map (sub 1) [1,2,3] -- returns [0,-1,-2]
----

But what if we want to do the reverse:

[source, morloc]
----
map ??? [1,2,3] -- we want to return [0,1,2]
----

One solution is to use anonymous function, lambdas, like so:

[source, morloc]
----
map (\x -> sub x 1) [1,2,3] -- returns [0,1,2]
----

Morloc also supports a shortcut for more flexible partial application using
underscores as placeholders:

[source, morloc]
----
map (sub _ 1) [1,2,3] -- returns [0,1,2]
----

This will be transformed in the compiler frontend to a lambda, so is behaves
identically. These placeholders may also be used in data structures. The
following two expressions obtain the same result:

[source, morloc]
----
map (\x -> (x,42)) [1,2,3] 
map (_,42) [1,2,3]
----

The placeholders may be used in nested data structures as well:

[source, morloc]
----
people :: [Person]
people = zipWith { country = "Pangea", name = _, age = _ } ["Alice", "Bob"] [42, 44]   
----

When multiple placeholders are used, the arguments generated for the lambda are
applied in left-to-right order.

Placeholders also work in string interpolation:

[source, morloc]
----
map "Hello #{_}!" ["Alice", "Bob"]
----


=== Where clauses

Functions may use `where` clauses to define local bindings:

[source, morloc]
----
f x = y + b where
    y = x + 1
    b = 41.0
----

Where clauses inherit the scope of their parent and may be nested:

[source, morloc]
----
f = x where
    x = y where
        y = a + b
        a = 1.0
    b = 41.0
----


=== Infix operators

Morloc supports user-defined infix operators with explicit associativity and
precedence. Operators are declared with `infixl` (left-associative) or `infixr`
(right-associative) followed by a precedence level (higher binds tighter):

[source, morloc]
----
infixl 6 +
infixl 7 *
infixr 8 **
----

Operators are given type signatures by wrapping them in parentheses:

[source, morloc]
----
(+) a :: a -> a -> a
(*) a :: a -> a -> a
(**) :: Int -> Int -> Int
----

Operators may be sourced from foreign languages like any other function:

[source, morloc]
----
source Py from "ops.py" ("add" as (+), "mul" as (*))
----

Infix operators work naturally with typeclasses:

[source, morloc]
----
class Num a where
    zero a :: a
    negate a :: a -> a
    (+) a :: a -> a -> a
    (*) a :: a -> a -> a

infixl 6 +
infixl 7 *

instance Num Int where
    source Py from "foo.py" ("add" as (+), "mul" as (*), "neg" as negate)
    zero = 0

-- now we can write natural expressions
test_expr :: Int
test_expr = 4 * 7 + 3  -- evaluates to 31 (precedence: 4*7 first, then +3)
----

Operators may also be imported from other modules:

[source, morloc]
----
import ops ((&), (|))
----


=== Native Morloc functions

While Morloc's primary purpose is composing foreign functions, you can also
define functions entirely in Morloc without sourcing from any language. These
_native_ functions are written using Morloc's own expression syntax:

[source, morloc]
----
module main (double, greet)

import root-py

double :: Real -> Real
double x = x + x

greet :: Str -> Str
greet name = "Hello #{name}!"
----

Native functions can use composition, `where` clauses, lambdas, and all other
Morloc expression forms. They are compiled down to whichever language the
compiler selects for execution.


=== Records

A record is internally a named tuple. Records may map to different structures in
different languages.

A general record is defined as follows:

[source, morloc]
----
record Person = Person
    { name :: Str
    , age :: Int
    }
----

Concrete forms must have the same field names and field types. Since these must
be the same, they need not be specified. We only need to specify the name of the
concrete type:

[source, morloc]
----
record Py => Person = "dict"
record R => Person = "list"
record Cpp => Person = "person_t"
----

In R and Python, records are typically `dict` and `list` types,
respectively. These types con contain any fields of any type. In {cpp}, records
are represented as structs; these must must be defined in the C code, as shown
below.

[source, cpp]
----
struct person_t {
    std::string name;
    int age;
};
----

Functions may be defined that act on the records, as below:

[source, morloc]
----
source R from "foo.R" ("incAge" as rinc)
source Py from "foo.py" ("incAge" as pinc)
source Cpp from "foo.hpp" ("incAge" as cinc)

-- Increment the person's age
rinc :: Person -> Person
pinc :: Person -> Person
cinc :: Person -> Person
----

Records may, like all `morloc` types, be passed freely between languages. As
shown above, records may be written in braces and their type will be inferred.

The "foo.R" file contains the function:

[source, r]
----
incAge <- function(person){
    person$age <- person$age + 1
    person
}
----

No special code is needed for `person`, it is just a builtin R list. Similarly for Python:

[source, python]
----
def incAge(person):
    person["age"] += 1
    return person
----

{cpp} requires a definition of a `person_t` struct:

[source, c++]
----
struct person_t {
    std::string name;
    int age;
};

person_t incAge(person_t person){
    person.age++;
    return person;
}
----

Records may be initialized and functions called on them:

[source, morloc]
----
foo name age
    = (rinc . pinc . cinc)
      { name = name, age = age }
----

`foo`, above, initializes a `Person` record and then increments its age 3 time
in different languages.

Records may contain fields with arbitrarily complex types, but recursive types
are not currently supported.

=== Tables

Tables are similar, but all fields are lists of equal length:

[source, morloc]
----
module foo (readPeople, addPeople)

import root-py (Int, Str)

source R from "people-tables.R"
   ( "read.delim" as readPeople
   , "addPeople")

table People = People
    { name :: Str
    , age :: Int
    }

readPeople :: Filename -> People
addPeople :: [Str] -> [Int] -> People -> People
----

With "people-tables.R" containing:

[source, r]
----
addPeople <- function(names, ages, df){
    rbind(df, data.frame(name = names, age = ages)) 
}
----

This can be compiled and run as so:

[source, bash]
----
# read a tab-delimited file containing person rows
./nexus readPeople data.tab > people.json

# add a row to the table
./nexus addPeople '["Eve"]' '[99]' people.json
----

The record and table types are currently strict. Defining functions that add or
remove fields/columns requires defining entirely new records/tables. Generic
functions for operations such as removing lists of columns cannot be defined at
all. For now, most operations should be done in coarser functions.
Alternatively, custom non-parameterized tabular/record types may be defined.

The case study in the Morloc
https://www.zebulun-arendsee.com/images/morloc-paper-001.pdf[paper] uses a
`JsonObj` type that represents an arbitrarily nested object that serializes
to/from JSON. In Python, it deserializes to a `dict` object; in R, to a `list`
objects; and in C to an `ordered_json` object from from
(https://github.com/nlohmann)[Niels Lohmann's json package]).

A similar approach could be used to define a non-parameterized table type that
serialized to CSV or some binary type (such as Parquet).

These non-parameterized solutions are flexible and easy to use, but lack the
reliability of the typed structures.


=== Type hierarchies

In some cases, there is a single obvious native type for a given Morloc general
type. For example, most languages have exactly only one reasonable way to
represent a boolean. However, other data types have may have many forms. The
Morloc `List` is a simple example. In Python, the `list` type is most often used
for representing ordered lists, however it is inefficient for heavy numeric
problems. In such cases, it is better to use a `numpy` vector. Further, there
are data structures that are isomorphic to lists but that are more efficient for
certain problems, such as stacks and queues.

We can define type hierarchies that represent these relationships.

[source, morloc]
----
-- aliases at the general level
type Stack       a = List a
type LList       a = List a
type ForwardList a = List a
type Deque       a = List a
type Queue       a = List a
type Vector      a = List a


-- define a C++ specialization for each special type
type Cpp => Stack a = "std::stack<$1>" a
type Cpp => LList a = "std::list<$1>" a
type Cpp => ForwardList a = "std::forward_list<$1>" a
type Cpp => Deque a = "std::deque<$1>" a
type Cpp => Queue a = "std::queue<$1>" a
----

Here we equate each of the specialized containers with the general `List`
type. This indicates that they all share the same common form and can all be
converted to the same binary. Then we specify language specific patterns as
desired. When the Morloc compiler seeks a native form for a type, it will
evaluate these type functions by incremental steps. At each step the compiler
first checks to see if there is a direct native mapping for the language, if
none is found, it evaluates the general type function.

Native type annotations are also passed to the language binders, allowing them
to implement specialized behavior for more efficient conversion to binary.


=== One term may have many definitions

Morloc supports what might be called _term polymorphism_. Each
term may have many definitions. For example, the function `mean` has three
definitions below:

[source, morloc]
----
import base (sum, div, size, fold, add)
import root-cpp
source Cpp from "mean.hpp" ("mean")
mean :: [Real] -> Real
mean xs = div (sum xs) (size xs)
mean xs = div (fold 0 add xs) (size xs)
----

`mean` is sourced directly from {cpp}, it is defined in terms of the `sum`
function, and it is defined more generally with `sum` written as a fold
operation. The Morloc compiler is responsible for deciding which
implementation to use.

The equals operator in Morloc indicates functional substitutability. When you
say a term is "equal" to something, you are giving the compiler an option for
what may be substituted for the term. The function `mean`, for example, has many
functionally equivalent definitions. They may be in different languages, or they
may be more optimal in different situations.

Now this ability to simply state that two things are the same can be abused. The
following statement is syntactically allowed in Morloc:

[source, morloc]
----
x = 1
x = 2
----

What is `x` after this code is run? It is 1 _or_ 2. The latter definition does
not mask the former, it _appends_ the former. Now in this case, the two values
are certainly not substitutable. Morloc has a simple _value checker_ that will
catch this type of primitive contradition. However, the value checker cannot yet
catch more nuanced errors, such as:

[source, morloc]
----
x = div 1 (add 1 1)
x = div 2 1
----

In this case, the type checker cannot check whithin the implementation of `add`,
so it cannot know that there is a contradiction. For this reason, some care is
needed in making these definitions.


=== Overload terms with typeclasses

In addition to term polymorphism, Morloc offers more traditional ad hoc
polymorphism over types. Here typeclasses may be defined and type-specific
instances may be given. This idea is similar to typeclasses in Haskell, traits
in Rust, interfaces in Java, and concepts in {cpp}.

In the example below, `Addable` and `Foldable` classes are defined and used to
create a polymorphic `sum` function.

[source, morloc]
----
class Addable a where
    zero a :: a
    add a :: a -> a -> a

instance Addable Int where
    source Py from "arithmetic.py" ("add" as add)
    source Cpp from "arithmetic.hpp" ("add" as add)
    zero = 0

instance Addable Real where
    source Py from "arithmetic.py" ("add" as add)
    source Cpp from "arithmetic.hpp" ("add" as add)
    zero = 0.0

class Foldable f where
    foldr a b :: (a -> b -> b) -> b -> f a -> b

instance Foldable List where
    source Py from "foldable.py" ("foldr" as foldr)
    source Cpp from "foldable.hpp" ("foldr" as foldr)

sum = foldr add zero
----

The instances may import implementations for many languages.

The native functions may themselves be polymorphic, so the imported
implementations may be repeated across many instances. For example, the Python
`add` may be written as:

[source,python]
----
def add(x, y):
    return x + y
----

And the {cpp} add as:

[source,cpp]
----
template <class A>
A add(A x, A y){
    return x + y;
}
----

Typeclasses may be imported from other modules. For example, a module that
defines the `Ord` typeclass and derived operators can be imported and
instantiated in another module:

[source, morloc]
----
import numops (Ord, (<), (>), (>=), min)

instance Ord Int where
    source Py from "foo.py" ("le" as (<=))
----

// === Ad hoc polymorphism (overloading and type classes)
//
// Morloc supports ad hoc polymorphism, where instances of a function may be
// defined for multiple types.
//
// Here is an example of a simple type classe, `Sizeable`, which represents objects
// that have be mapped to an integer that conveys the notion of size:
//
// [source, morloc]
// ----
// module size (add)
//
// class Sizeable a where
//   size a :: a -> Int
// ----
//
// Instances of `Sizeable` may be defined in this module or in modules that import
// this module. For example:
//
// [source, morloc]
// ----
// module foo *
//
// type Cpp => List a = "std::vector<$1>" a
// type Py => List a = "list" a
//
// type Cpp => Str = "std::string"
// type Py => Str = "str"
//
// instance Sizeable [a] where
//   source Cpp "foo.hpp" ("size" as size)
//   source Py ("len" as size)
//
// instance Sizeable Str where
//   source Cpp "foo.hpp" ("size" as size)
//   source Py ("len" as size)
// ----
//
// Where in {cpp}, the generic function `size` returns length for any {cpp} size
// with a `size` method. For Python, the builtin `len` can be directly used.
//
// Morloc also supports multiple parameter typeclasses, such as in the `Packable`
// typeclass below:
//
// [source, morloc]
// ----
// class Packable a b where
//   pack a b :: a -> b
//   unpack a b :: b -> a
// ----
//
// This specific typeclass is special in the Morloc ecosystem since it handles
// the simplification of complex types before serialization. Instances may overlap
// and the most specific one will be selected. `Packable` may have instances such
// as the following:
//
// [source, morloc]
// ----
// instance Packable [a] (Queue a) where
//   ...
//
// instance Packable [a] (Set a) where
//   ...
//
// instance Packable [(a,b)] (Map a b) where
//   ...
//
// instance Packable [(Int,b)] (Map Int b) where
//   ...
// ----




=== Binary forms

Every Morloc general type maps unambiguously to a binary form that consists of
several fixed-width literal types, a list container, and a tuple container. The
literal types include a unit type, a boolean, signed integers (8, 16, 32, and 64
bit), unsigned integers (8, 16, 32, and 64 bit), and IEEE floats (32 and 64 bit). The
list container is represented by a 64-bit size integer and a pointer to an
unboxed vector. The tuple is represented as a set of values in contiguous
memory. These basic types are listed below:

.Morloc primitives
[cols="2, 1, 2, 1"]
|===
| Type | Domain | Schema | Width (bytes)

| Unit | `()` | z | 1
| Bool | `True` \| `False` | b | 1
| UInt8 | latexmath:[[0,2^{8})] | u1 | 1
| UInt16 | latexmath:[[0,2^{16})] | u2 | 2
| UInt32 | latexmath:[[0,2^{32})] | u4 | 4
| UInt64 | latexmath:[[0,2^{64})] | u8 | 8
| Int8 | latexmath:[[-2^{7},2^{7})] | i1 | 1
| Int16 | latexmath:[[-2^{15},2^{15})] | i2 | 2
| Int32 | latexmath:[[-2^{31},2^{31})] | i4 | 4
| Int64 | latexmath:[[-2^{63},2^{63})] | i8 | 8
| Float32 | IEEE float | f4 | 4
| Float64 | IEEE double | f8 | 8
| List x | het lists | a{x} | latexmath:[16 + n \Vert a \Vert ]
| Tuple2 x1 x2 | 2-ples | t2{x1}{x2} | latexmath:[\Vert a \Vert + \Vert b \Vert]
| TupleX latexmath:[\ t_i\ ...\ t_k] | k-ples | latexmath:[tkt_1\ ...\ t_k] | latexmath:[\sum_i^k \Vert t_i \Vert]
| latexmath:[\{ f_1 :: t_1,\ ... \ , f_k :: t_k \}] | records | latexmath:[mk \Vert f_1 \Vert f_1 t_1\ ...\ \Vert f_k \Vert f_k t_k ] | latexmath:[\sum_i^k \Vert t_i \Vert]
|===

All basic types may be written to a schema that is used internally to direct
conversions between Morloc binary and native basic types. The schema values
are shown in the table above. For example, the type `[(Bool, [Int8])]` would
have the schema `at2bai1`. You will not usually have to worry about these
schemas, since they are mostly used internally. They are worth knowing, though,
since they appear in low-level tests, generated source code, and binary data
packets.

Here is an example of how the type `([UInt8], Bool)`, with the value
`([3,4,5],True)`,  might be laid out in memory:

[source]
---
03 00 00 00 00 00 00 00 00 -- first tuple element, specifies list length (little-endian)
30 00 00 00 00 00 00 00 00 -- first tuple element, pointer to list
01 00 00 00 00 00 00 00 00 -- second tuple element, with 0-padding
03 04 05                   -- 8-bit values of 3, 4, and 5
---

Records and tables are represented as tuples. The names for each field are stored only in
the type schemas. Morloc also supports tables, which are just records where
the field types correspond to the column types and where fields are all
equal-length lists. Records and tables may be defined as shown below:

A `record` is a named, heterogenous list such as a `struct` in C, a `dict` in
Python, or a `list` in R. The type of the record exactly describes the data
stored in the record (in contrast to parameterized types like `[a]` or `Map a
b`). They are represented in Morloc binary as tuples, the keys are only stored
in the schemas.

A `table` is like a record where field types represent the column types. But
`table` is not just syntactic sugar for a record of lists, the `table`
annotation is passed with the record through the compiler all the way to the
translator, where the language-specific serialization functions may have special
handling for tables.

[source, morloc]
----
record Person = Person { name :: Str, age :: UInt8 }
table People = People { name :: Str, age :: Int }

alice = { name = "Alice", age = 27 }
students = { name = ["Alice", "Bob"], age = [27, 25] }
----

The Morloc type signatures can be translated to schema strings that may be
parsed by a foundational Morloc C library into a type structure. Every
supported language in the Morloc ecosystem must provide a library that wraps
this Morloc C library and translates to/from Morloc binary given the
Morloc type schema.


=== Defining non-primitive types

Types that are composed entirely of Morloc primitives, lists, tuples, records
and tables may be directly and unambiguously translated to Morloc binary forms
and thus shared between languages. But what about types that do not break down
cleanly into these forms? For example, consider the parameterized `Map k v` type
that represents a collection with keys of generic type `k` and values of generic
type `v`. This type may have many representations, including a list of pairs, a
pair of columns, a binary tree, and a hashmap. In order for Morloc to know how
to convert all `Map` types in all languages to one form, it must know how to
express `Map` type in terms of more primitive types. The user can provide this
information by defining instances of the `Packable` typeclass for `Map`. This
typeclass defines two functions, `pack` and `unpack`, that construct and
deconstruct a complex type.

[source, morloc]
----
class Packable a b where
    pack a b :: a -> b
    unpack a b :: b -> a
----

The `Map` type for Python and {cpp} may be defined as follows:

[source, morloc]
----
type Py => Map key val = "dict" key val
type Cpp => Map key val = "std::map<$1,$2>" key val
instance Packable ([a],[b]) (Map a b) where
    source Cpp from "map-packing.hpp" ("pack", "unpack")
    source Py from "map-packing.py" ("pack", "unpack")
----

The Morloc user never needs to directly apply the `pack` and `unpack`
functions. Rather, these are used by the compiler within the generated code. The
compiler constructs a serialization tree from the general type and from this
trees generates the native code needed to (un)pack types recursively until only
primitive types remain. These may then be directly translated to Morloc binary
using the language-specific binding libraries.

In some cases, the native type may not be as generic as the general type. Or you
may want to add specialized (un)packers. In such cases, you can define more
specialized instances of `Packable`. For example, if the `R` `Map` type is
defined as an `R` list, then keys can only be strings. Any other type should
raise an error. So we can write:

[source, morloc]
----
type R => Map key val = "list" key val
instance Packable ([Str],[b]) (Map Str b) where
source R from "map-packing.R" ("pack", "unpack")
----

Now whenever the key generic type of `Map` is inferred to be anything other than
a string, all R implementations will be pruned.





// ## Status
//
// This project is under heavy development and I may make backwards incompatible
// changes without notice until the v1.0 release (hence the "unstable" badge). Pull
// requests, issue reports, and private messages are very welcome.
//
// ## Running morloc
//
// The easiest way to start using `morloc` is through containers. I recommend using
// podman, since it doesn't require a daemon or sudo access. But Docker,
// Singularity, and similar tools should suffice.
//
// A container with the morloc executable and batteries included can be retrieved
// from the GitHub container registry as follows:
//
// ```bash
// $ podman pull ghcr.io/morloc-project/morloc/morloc-full:0.53.7
// ```
//
// The `v0.53.7` may be replaced with the desired `morloc` version.
//
// Now you can enter a shell with a full working installation of `morloc`:
//
// ```bash
// $ podman run --shm-size=4g -v $HOME:$HOME -w $PWD -e HOME=$HOME -it ghcr.io/morloc-project/morloc/morloc-full:0.53.7 /bin/bash
// ```
//
// The `--shm-size=4g` option sets the shared memory space to 4GB. `morloc` uses
// shared memory for communication between languages, but containers often limit
// the shared memory space to 64MB by default.
//
// Alternatively, you can set up a script to run commands in a `morloc` environment:
//
// ```bash
// podman run --rm \
//            --shm-size=4g \
//            -e HOME=$HOME \
//            -v $HOME/.morloc:$HOME/.morloc \
//            -v $PWD:$HOME \
//            -w $HOME \
//            ghcr.io/morloc-project/morloc/morloc-full:0.53.7 "$@"
// ```
//
// Name this script `menv`, for "morloc environment", make it executable, and place
// it in your PATH. The script will mount your current working directory and your
// `morloc` home directory, allowing you to run commands in a morloc-compatible
// environment.
//
// You can can run commands like so:
//
// ```
// $ menv morloc --version      # get the current morloc version
// $ menv morloc -h             # list morloc commands
// $ menv morloc init -f        # setup the morloc environment
// $ menv morloc install types  # install a morloc module
// $ menv morloc make foo.loc   # compile a local morloc module
// ```
//
// The generated executables may not work on your system since they were compiled
// inside the container, but you can run them also in the `morloc` environment:
//
// ```
// $ menv ./nexus foo 1 2 3
// ```
//
// More advanced solutions with richer dependency handling will be introduced in
// the future, but for now this allows easy experimentation with the language in a
// safe(ish) sandbox.
//
// ## Installing from source
//
// Unless you are hacking on the compiler itself, I don't recommend building from
// source. Doing so will require a working Haskell environment. Running examples
// may also require installing Python, R, and suitable C++ compilers. If you still
// want to build from source, I recommend you read the `morloc` Dockerfile's in the
// `container` folder. They contain instructions that will at point you in the
// right direction.
//
// ## Installing `morloc` modules
//
// `morloc` modules can be installed from the `morloc`
// [library](https://github.com/morloclib) with the commands such as:
//
// ```sh
// morloc install types
// morloc install conventions
// morloc install base
// morloc install cppbase
// morloc install pybase
// morloc install rbase
// morloc install math
// ```
//
// The `morloc install` commands will install the modules in the
// `$HOME/.morloc/lib` folder.
//
// `morloc install conventions` can be used to install the `conventions` module,
// which is a dependency for most programs importing modules.
//
// Last of all, if you are working in vim, you can install `morloc` syntax
// highlighting as follows:
//
// ``` sh
// mkdir -p ~/.vim/syntax/
// mkdir -p ~/.vim/ftdetect/
// cp vim-syntax/loc.vim ~/.vim/syntax/
// echo 'au BufRead,BufNewFile *.loc set filetype=loc' > ~/.vim/ftdetect/loc.vim
// ```
//
// ## Getting Started
//
// ```
// module hw (hello)
//
// hello = "Hello World"
// ```
//
// We create a module named `hw` and export the `hello` term.
//
// Paste this into a file (e.g. "hello.loc") and then it can be imported by other
// `morloc` modules or directly compiled into a program where every exported term
// is a subcommand.
//
// ```
// morloc make -o nexus hello.loc
// ```
//
// This will generate a single file named "nexus". The nexus file is the executable
// script that the user will interact with. For this simple example, it is the
// only generated file.
//
// Calling "nexus" with no arguments or with the `-h` flag, will print a help
// message:
//
// ```
// $ ./nexus -h
// The following commands are exported:
//   hello
//     return: Str
// ```
//
// The `return: Str` phrases states that hello returns a string value.
//
// The command `hello` can be called as shown below:
//
// ```
// $ ./nexus hello
// Hello World
// ```
//
// ## Composing C++ Functions
//
// The following code uses only C++ functions (`fold`, `map`, `add` and `mul`).
//
// ```
// module sos (square, sumOfSquares)
//
// import types (Real, List)
// import cppbase (fold, map)
//
// square :: Real -> Real
// square x = mul x x
//
// sumOfSquares :: [Real] -> Real
// sumOfSquares xs = fold add 0.0 (map square xs)
// ```
//
// If this script is pasted into the file "example-1.loc", it can be compiled as
// follows:
//
// ```sh
// morloc install cppbase
// morloc make -o nexus example-1.loc
// ```
//
// The `install` command clones the `cppbase` repo from github
// [repo](https://github.com/morloclib/cppbase) into the local directory
// `~/.morloc/lib`. The `morloc make -o nexus` command will generate a file named
// `nexus`, which is an executable interface to the exported functions.
//
// You can see typed usage information for the exported functions with the `-h` flag:
//
// ```sh
// $ ./nexus -h
// The following commands are exported:
//   square
//     param 1: Real
//     return: Real
//   sumOfSquares
//     param 1: [Real]
//     return: Real
// ```
//
// Then you can call the exported functions (arguments are in JSON format):
//
// ```sh
// $ ./nexus sumOfSquares '[1,2,3]'
// 14
// ```
//
// The `nexus` executable dispatches the command to the compiled C++ program,
// `pool-cpp.out`.
//
//
// ## Language interop
//
// `morloc` can compose functions across languages. For example:
//
// ```
// module fib (fibplot)
//
// import math (fibonacci)
// import rbase (plotVectorPDF, ints2reals)
//
// fibplot n = plotVectorPDF (ints2reals (fibonacci n)) "fibonacci-plot.pdf"
// ```
//
// The `fibplot` function calculates Fibonacci numbers using a C++ function and
// plots it using an R function. The R function `plotPDF` is a perfectly normal R
// function with no extra boilerplate:
//
// ``` R
// plotPDF <- function(x, filename){
//   pdf(filename)
//   plot(x)
//   dev.off()
// }
// ```
//
//
// ## The Morloc Type System
//
// The first level of the `morloc` type system is basically System F extended
// across languages. A given function will have a general type as well as a
// specialized type for each language it is implemented in.
//
// The map function has the general type
//
// ```
// map a b :: (a -> b) -> List a -> List b
// ```
//
// Lowercase terms, such as `a` and `b`, represent generic variables. The `->`
// delimited patterns represent functions. So `a -> b` represents a function that
// takes a value of type `a` and returns `b`. `List a` is a parameterized type, in
// this case a container of elements of type `a`. The generic variables need to be
// explicitly declared (in the `map a b` expression).
//
// `morloc` can derive the language-specific type signatures from the general one
// if it knows the language-specific instances of `List`. We can tell the compiler
// these mappings by defining language-specific type relations:
//
// ```
// type Py => List a = "list" a
// type Py => Int = "int"
//
// type Cpp => List a = "std::vector<$1>" a
// type Cpp => Int = "int"
// ```
//
// The list type constructor for C++ is literally a "type constructor" in that it
// is used to create a syntactically correct C++ type string. If the type variable
// `a` is inferred to be `Int`, for example, then the C++ type `std::vector<int>`
// will be used in the generated C++ signature. The same occurs in the python type
// constructors `list`, except here the same Python type, `list`, is generated
// regardless of the type of `a`.
//
// This following example is the same as the previous but without imports.
//
// ```
// module sos (square, sumOfSquares)
//
// type Cpp => Real = "double"
// type Cpp => List a = "std::vector<$1>" a
//
// add :: Real -> Real -> Real
// mul :: Real -> Real -> Real
// fold a b :: (b -> a -> b) -> b -> [a] -> b
// map a b :: (a -> b) -> [a] -> [b]
//
// square x = mul x x
// sumOfSquares xs = fold add 0.0 (map square xs)
// ```
//
// No implementations are given for the functions, so the code cannot be
// compiled. It can, however, be typechecked:
//
// ```
// $ morloc typecheck examples/rmsWithTypes.loc
// ```
//
// The typechecker associates each sub-expression of the program with a set of
// types. The specific type information in `mul` is sufficient to infer concrete
// types for every other C++ function in the program. The inferred C++ type of
// `sumOfSquares` is
//
// ```
// "std::vector<$1>" "double" -> "double"
// ```
//
// The general type for this expression is inferred as:
//
// ```
// List Real -> Real
// ```
