=== One term may have many definitions

Morloc supports what might be called _term polymorphism_. Each
term may have many definitions. For example, the function `mean` has three
definitions below:

[source, morloc]
----
import base (sum, div, size, fold, add)
import root-cpp
source Cpp from "mean.hpp" ("mean")
mean :: [Real] -> Real
mean xs = div (sum xs) (size xs)
mean xs = div (fold 0 add xs) (size xs)
----

`mean` is sourced directly from {cpp}, it is defined in terms of the `sum`
function, and it is defined more generally with `sum` written as a fold
operation. The Morloc compiler is responsible for deciding which
implementation to use.

The equals operator in Morloc indicates functional substitutability. When you
say a term is "equal" to something, you are giving the compiler an option for
what may be substituted for the term. The function `mean`, for example, has many
functionally equivalent definitions. They may be in different languages, or they
may be more optimal in different situations.

Now this ability to simply state that two things are the same can be abused. The
following statement is syntactically allowed in Morloc:

[source, morloc]
----
x = 1
x = 2
----

What is `x` after this code is run? It is 1 _or_ 2. The latter definition does
not mask the former, it _appends_ the former. Now in this case, the two values
are certainly not substitutable. Morloc has a simple _value checker_ that will
catch this type of primitive contradition. However, the value checker cannot yet
catch more nuanced errors, such as:

[source, morloc]
----
x = div 1 (add 1 1)
x = div 2 1
----

In this case, the type checker cannot check whithin the implementation of `add`,
so it cannot know that there is a contradiction. For this reason, some care is
needed in making these definitions.


