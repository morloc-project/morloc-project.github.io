

=== Architecture Overview

A compiled Morloc program has two kinds of components: one **nexus** and one or
more **pools**.

The **nexus** is a pre-compiled C binary that serves as the CLI entry point. It
reads a JSON manifest describing the program's structure, parses command-line
arguments, and orchestrates execution. The nexus starts pool daemons, sends them
call packets over Unix domain sockets, and prints the result. When done, it
tears everything down.

**Pools** are language-specific daemons -- one per language used in the program.
A pool contains all functions from its language, compiled into a single unit.
Pools listen on Unix sockets for call packets, dispatch to the appropriate
function, and return results. All pools are **multi-threaded** (or
multi-process), starting with one worker and growing dynamically as needed.

The nexus and pools share a **shared memory region** for passing data. In the
common case, only 8-byte relative pointers travel over sockets -- the actual
data lives in shared memory visible to all processes. Pools can also call each
other directly for cross-language ("foreign") calls, without routing through the
nexus.

[mermaid]
....
sequenceDiagram
    participant User
    participant Nexus
    participant Pool A
    participant Pool B

    User->>Nexus: ./myprogram subcmd args...
    Nexus->>Pool A: fork + exec
    Nexus->>Pool B: fork + exec

    Nexus->>Pool A: call packet (mid, args)
    Pool A->>Pool A: dispatch(mid, args)

    opt Foreign call needed
        Pool A->>Pool B: call packet over Unix socket
        Pool B-->>Pool A: data packet (result)
    end

    Pool A-->>Nexus: data packet (result)
    Nexus->>User: print result
....


Here are a runtime rules you should be able to count on. Any violations should
be considered bugs.

1. **STDOUT and STDERR pass through.** Any output written to stdout or stderr
   by user functions is never intercepted or buffered by the Morloc runtime. It
   passes directly to the terminal.

2. **Errors become tracebacks.** All exceptions raised by user functions are
   caught by the pool and returned as error packets. As the error propagates
   back through foreign calls to the nexus, each layer appends context,
   building a full cross-language traceback that the user can read.

3. **Intra-pool calls are near-native.** Calls between functions within the
   same pool go through a simple dispatch table -- there is no serialization,
   no socket overhead, and no IPC. Performance should be nearly native.

4. **Inter-pool calls cost socket time plus marshalling.** A call between pools
   (or between the nexus and a pool) pays only the few microseconds of Unix
   socket round-trip plus the cost of data marshalling. In the best case, the
   data in shared memory can be directly used between programs and marshalling
   cost is zero. In practice, copies are often needed -- for example, Python
   demands ownership of its strings even when the data could in principle be
   shared directly.
