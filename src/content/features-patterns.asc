=== Pattern functions for data access/update

Data structures may be accessed and modified using pattern functions. These
patterns may be _getters_ that extract a tuple of values from a data structure
or _setters_ that update a data structure without changing its type.

.getters patterns

A *getter* pattern describes an optionally branching path into a data
structure. Each segment of the path may be a tuple index, a record key, or a
group of indices/keys. The terminal positions in the pattern are returned as
elements in a tuple. Here are a few examples:

[source, morloc]
----
-- return the 1st element in a tuple of any size
.0 (1,2) -- return 1
.0 ((1,3),2,5) -- return (1,3)

-- return the 2nd element in the first element of a tuple
.0.1 ((1,3),2,5) -- return 3 

-- returns the 2nd and 1st elements in a tuple
.(.1,.0) (1,2,3) -- returns (2,1)
.(.1,.0) (1,2)   -- returns (2,1)

-- indices and keys may be used together
.0.(.x, .y.1) ({x=1, y=(1,2), z=3}, 6) -- returns (1,2)
----

These patterns are transformed into functions may be used exactly like any other
function.

[source, morloc]
----
map .1 [(1,2),(2,3)] -- returns [2,3]
----

.setters patterns

Setter patterns are similar but add an assignment statement to each pattern
terminus.

[source, morloc]
----
.(.0 = 99) (1,2) -- return (99,2)

-- indices and keys may be used together
.0.(.x=99, .y.1=33) ({x=1, y=(1,2), z=3}, 6) -- returns ({x=99, y=(1,33), z=3}, 6)
----

.Comparison of patterns to Python syntax
[cols="2, 2, 3"]
|===
| Pattern                 | Python                   | Note
                          
| .0                      | lambda x: x[0]           | patterns are functions
| .0 x                    | x[0]                     |
| .0.k x                  | x[0]["k"]                |
| .(.1,.0) x              | (x[1], x[0])             |
| foo .0 xs               | foo(lambda x: x[0], xs)  | higher order
| .(.k = 1) x             | x["k"] = 1               |
|===

Note that setters are designed to not mutate data. The *spine* of the data
structure will be copied which retains links to the original data for unmodified
fields. So the expression `.(.0 = 42) x` when translated into Python will create
a new tuple with the first field being 42 and the remaining fields assigned to
elements of the original field. The same goes for records.

