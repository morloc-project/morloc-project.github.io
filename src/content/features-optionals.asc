=== Optional types

All programming languages must have a way to deal with missing values. If you
query a database for a record that doesn't exist, what is returned? If a
parameter is not set, what value does it have? In Python, the `None` type stores
missing values. In R, `NULL` serves a similar purpose. In both languages, types
that may lack values are represented as a union of the original type and the
`null` type. JSON, similarly, stores missing values as `null`. Other languages
solve this problem in libraries. C++ has the standard template library
datastructure `std::optional<T>` for representing values of generic type `T`
that have null, `std::nullopt` types.

Haskell offers the `Maybe` sum type that may be `Nothing` or `Just a`. This is
perhaps the cleanest solution, but it is not practical for Morloc. One of the
core principles of Morloc is that sourced functions should be idiomatic. So
Morloc needs a built-in mechanism that can vary freely in language-specific
implementation while preserving between language consistency. To this end,
Morloc offers a dedicated "Optional" type with supported implicit coercion.

==== Syntax

The `?` prefix marks a type as optional and the `null` primitive indicates an
absent value. `?Int` is an integer that might be `null`, `?Str` is a string that
might be `null`, and so on. The `?` prefix can be applied to any type, including
lists (`?[Int]`), records (`?Person`), and nested optionals (`??Int`).

[source, morloc]
----
--' Get the first element from a list or empty on failure
safeHead :: [Int] -> ?Int
fromNull a :: a -> ?a -> a
----

The `null` keyword represents an absent value:

[source, morloc]
----
testNull :: ?Int
testNull = null
----

==== Working with optional values

Functions that produce or consume optional values are sourced from foreign
languages like any other function. Here is a complete example in Python:

[source, morloc]
----
module main (testSafeHead, testSafeHeadEmpty, testFromNull)

import root-py

safeHead :: [Int] -> ?Int
safeHead xs
  ? length xs == 0 = null
  : head xs

source Py from "main.py" ("fromNull")
fromNull a :: a -> ?a -> a

testSafeHead :: ?Int
testSafeHead = safeHead [10, 20, 30]

testSafeHeadEmpty :: ?Int
testSafeHeadEmpty = safeHead []

testFromNull :: Int
testFromNull = fromNull 0 null
----

The Python implementations handle `None` in the usual way:

[source, python]
----
def fromNull(default_val, x):
    if x is None:
        return default_val
    return x
----

Running this program gives:

----
$ ./main testSafeHead
10
$ ./main testSafeHeadEmpty
null
$ ./main testFromNull
0
----

The same pattern works in {cpp} (using `std::optional`) and R (using `NULL`).
In {cpp}:

[source, c++]
----
#include <optional>

template <class T>
T fromNull(T default, const std::optional<T>& x) {
  if(x.has_value()){
    return x.value();
  } else {
    return default;
  }
}
----

In R:

[source, r]
----
fromNull <- function(default_val, x){
  if(is.null(x)){
    return default_val
  } else {
    return x
  }
}
----

==== Optional record fields

Record fields can be optional. This is useful for data with missing or unknown
values:

[source, morloc]
----
record Person where
  name :: Str
  age :: ?Int
record Py => Person = "dict"

makePerson :: Str -> ?Int -> Person
source Py from "foo.py" ("makePerson")

alice :: Person
alice = makePerson "Alice" (toNull 30)

bob :: Person
bob = makePerson "Bob" null
----

When serialized to JSON, `alice` becomes `{"name":"Alice","age":30}` and the
age field of `bob` becomes `null`.

==== Optional values across languages

Optional types work seamlessly across language boundaries. A function in one
language can produce an optional value that is consumed by a function in another:

[source, morloc]
----
-- C++ produces an optional value
cSafeDiv :: Int -> Int -> ?Int
source Cpp from "foo.hpp" ("cSafeDiv")

-- Python consumes it
pFromNull :: Int -> ?Int -> Int
source Py from "foo.py" ("pFromNull")

-- Chain them together: C++ to Python
testCppToPy :: Int
testCppToPy = pFromNull (-1) (cSafeDiv 10 3)

testCppToPyNull :: Int
testCppToPyNull = pFromNull (-1) (cSafeDiv 10 0)
----

The Morloc compiler generates the necessary serialization code at each language
boundary. A `null` value in {cpp} (`std::nullopt`) is serialized as JSON `null`,
which Python reads as `None`. The programmer does not need to handle the interop
manually.

==== Implicit coercion

Morloc automatically coerces a non-optional value to an optional when the
context requires it. If a function expects `?Int`, you can pass a plain `Int`
without wrapping it:

[source, morloc]
----
addOpt :: ?Int -> ?Int -> ?Int
source Py from "foo.py" ("addOpt")

-- Both arguments are plain Int, coerced to ?Int automatically
testCoerceAddOpt :: ?Int
testCoerceAddOpt = addOpt 3 4

fromNull a :: a -> ?a -> a
source Py from "foo.py" ("fromNull")

-- The second argument (42) is Int, coerced to ?Int
testCoerceArg :: Int
testCoerceArg = fromNull 0 42
----

This coercion is transitive: `a` coerces to `?a`, which coerces to `??a`.

Coercion also works across language boundaries. If a {cpp} function returns
`Int` and a Python function expects `?Int`, the compiler inserts the appropriate
serialization so that the value is received correctly:

[source, morloc]
----
-- C++ returns a plain Int
cAddOne :: Int -> Int
source Cpp from "cfoo.hpp" ("cAddOne")

-- Python expects ?Int in the second argument
pUnwrapOr a :: a -> ?a -> a
source Py from "pfoo.py" ("pUnwrapOr")

-- The Int result from C++ is coerced to ?Int for Python
testCppIntToPyOpt :: Int
testCppIntToPyOpt = pUnwrapOr 0 (cAddOne 41)  -- returns 42
----

==== Language mapping

Optional types map to native nullable types in each language:

[cols="1,2", options="header"]
|===
| Language | Representation

| Python | `None` for null, plain value otherwise
| {cpp} | `std::optional<T>`
| R | `NULL` for null, plain value otherwise
|===

No special type mappings are needed for optionals -- the `?` prefix works with
any type that already has a language mapping.
