=== The Morloc Packet Protocol

All communication between the nexus and pool daemons -- and between pools
themselves -- uses a binary packet protocol. Packets are sent over Unix domain
sockets as contiguous byte streams.


==== The 32-byte header

Every packet starts with a 32-byte header. The header is a packed C struct
(`morloc_packet_header_t`) with no padding, guarded by a
`static_assert(sizeof(...) == 32)`.

.Packet header specification
[cols="2, 2, 1, 10"]
|===
| Field     | Type         | Width | Description

| `magic`   | uint32_t     | 4     | Constant `0x0707f86d` (little-endian). If this doesn't match, the packet is rejected.
| `plain`   | uint16_t     | 2     | Morloc "plain" membership. Plains are disjoint sets of libraries that follow different conventions. Not yet used; always 0.
| `version` | uint16_t     | 2     | Packet format version. Currently 0.
| `flavor`  | uint16_t     | 2     | Metadata convention. Not yet used.
| `mode`    | uint16_t     | 2     | Evaluation mode (e.g., debug, verbose). Not yet used.
| `command` | union        | 8     | Type-specific command data (see below).
| `offset`  | uint32_t     | 4     | Number of bytes of metadata between the header and the payload.
| `length`  | uint64_t     | 8     | Length of the payload in bytes.
|===

[mermaid]
....
packet-beta
    0-31: "magic (4B)"
    32-47: "plain (2B)"
    48-63: "version (2B)"
    64-79: "flavor (2B)"
    80-95: "mode (2B)"
    96-159: "command (8B)"
    160-191: "offset (4B)"
    192-255: "length (8B)"
....

The total packet size is always `32 + offset + length`. The `offset` bytes
between the header and payload contain metadata blocks (see below). If there's
no metadata, `offset` is 0 and the payload starts immediately after the header.


// ==== Packet types
//
// The `command` field is an 8-byte union. The first byte is always a type tag
// that identifies the packet type:
//
// * `0x00` -- Data packet
// * `0x01` -- Call packet
// * `0x02` -- Ping packet
//
//
// ==== Data packets
//
// Data packets carry data or error messages. They're used for:
//
// * Arguments passed between the nexus and pool daemons
// * Results returned from function calls
// * Intermediate data that hasn't been converted to native types (enabling
//   zero-copy transfer between languages)
// * Final output written by the nexus to stdout
//
// .Data packet command field
// [cols="2, 2, 1, 10"]
// |===
// | Field         | Type    | Width | Description
//
// | `type`        | uint8_t | 1     | Constant `0x00`
// | `source`      | uint8_t | 1     | Where the data lives
// | `format`      | uint8_t | 1     | Encoding of the data
// | `compression` | uint8_t | 1     | Compression algorithm (reserved, always 0)
// | `encryption`  | uint8_t | 1     | Encryption algorithm (reserved, always 0)
// | `status`      | uint8_t | 1     | `0x00` = PASS, `0x01` = FAIL
// | `padding`     | uint8_t | 2     | Zero padding
// |===
//
// **Source** values:
//
// [cols="1, 2, 6"]
// |===
// | Code | Name | Description
//
// | `0x00` | MESG | The data is inline in the packet payload
// | `0x01` | FILE | The payload is a file path; the data lives in that file
// | `0x02` | RPTR | The payload is an 8-byte relative pointer into shared memory
// |===
//
// **Format** values:
//
// [cols="1, 2, 6"]
// |===
// | Code | Name | Description
//
// | `0x00` | JSON     | JSON-encoded data
// | `0x01` | MSGPACK  | MessagePack-encoded data
// | `0x02` | TEXT     | Plain text (typically error messages)
// | `0x03` | DATA     | Raw binary data
// | `0x04` | VOIDSTAR | Morloc's native binary format (see <<_schemas_and_serialization>>)
// |===
//
// The most common combination in practice is `source=RPTR, format=VOIDSTAR` --
// the data lives in shared memory in Morloc's native binary layout, and only an
// 8-byte pointer travels over the socket. This is the zero-copy fast path.
//
// When shared memory isn't available (e.g., cross-machine calls), `source=FILE,
// format=MSGPACK` is used -- the data is serialized to a MessagePack file, and the
// packet carries the file path.
//
//
// ==== Call packets
//
// Call packets instruct a pool to execute a specific function. The payload is a
// contiguous sequence of data packets, one per argument.
//
// .Call packet command field
// [cols="2, 2, 1, 10"]
// |===
// | Field        | Type     | Width | Description
//
// | `type`       | uint8_t  | 1     | Constant `0x01`
// | `entrypoint` | uint8_t  | 1     | `0x00` = LOCAL, `0x01` = REMOTE_SFS
// | `padding`    | uint8_t  | 2     | Zero padding
// | `midx`       | uint32_t | 4     | Manifold index -- identifies which function to call
// |===
//
// The `entrypoint` field distinguishes local calls (within the same machine) from
// remote calls on a shared filesystem (e.g., in a SLURM cluster).
//
//
// ==== Ping packets
//
// Ping packets are header-only (no payload). They're used by the nexus to check
// whether a pool daemon is up and ready to accept work.
//
// .Ping packet command field
// [cols="2, 2, 1, 10"]
// |===
// | Field     | Type    | Width | Description
//
// | `type`    | uint8_t | 1     | Constant `0x02`
// | `padding` | uint8_t | 7     | Zero padding
// |===
//
// A pool responds to a ping by echoing the packet back (a "pong"). The nexus
// pings each pool with exponential backoff until it gets a response.
//
//
// ==== Metadata blocks
//
// Between the header and the payload (in the region described by `offset`),
// packets can carry zero or more metadata blocks. Each block starts with an
// 8-byte header:
//
// .Metadata block header
// [cols="2, 2, 1, 10"]
// |===
// | Field   | Type     | Width | Description
//
// | `magic` | char[3]  | 3     | Constant `"mmh"` (Morloc Metadata Header)
// | `type`  | uint8_t  | 1     | Metadata type
// | `size`  | uint32_t | 4     | Size of the metadata payload in bytes
// |===
//
// Currently two metadata types are defined:
//
// * `0x01` -- **SCHEMA_STRING**: A schema string describing the data type (e.g.,
//   `"ai4"` for an array of 32-bit signed integers). This lets the receiver
//   interpret the payload without out-of-band type information.
// * `0x02` -- **XXHASH**: A 64-bit xxHash digest of the data, used for caching
//   and integrity checks.
//
// The metadata system is designed to be extensible. Future uses could include
// provenance tracking, benchmark data, environment info, or runtime DAGs.
//
//
// ==== Fail packets
//
// When a computation fails, the pool returns a data packet with `status=FAIL`,
// `source=MESG`, and `format=TEXT`. The payload is a UTF-8 error message string.
// The nexus prints this message to stderr and exits with a non-zero status.
//
//
// ==== Output formats
//
// When the nexus receives a result, it can print it in one of three formats
// (selected by the `-f` flag):
//
// * **`json`** (default) -- The voidstar data is converted to JSON and printed to
//   stdout. This is human-readable and compatible with standard tooling (`jq`,
//   etc.).
// * **`mpk`** -- The voidstar data is serialized to MessagePack and written to
//   stdout as raw bytes. Useful for piping into other programs that speak
//   MessagePack.
// * **`voidstar`** -- The raw Morloc binary packet (header + metadata + payload)
//   is written to stdout. This preserves the full packet structure and is the most
//   efficient for machine-to-machine communication.
