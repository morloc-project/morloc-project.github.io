=== Schemas and Serialization

Morloc has its own compact binary data representation ("voidstar") and a schema
language that describes how to interpret it. Schemas are the bridge between
Morloc's type system and its runtime data layout -- they tell the runtime how to
serialize, deserialize, and print data without needing the original types at
hand.


==== Schema strings

A schema string is a compact, human-readable encoding of a data type's binary
layout. The Haskell compiler generates schema strings and embeds them in the
manifest and in packet metadata. The C runtime parses them into `Schema` structs.

Primitive schemas are a letter followed by a width in bytes:

[cols="1, 2, 4"]
|===
| Schema | Type | Description

| `z` | nil | Null/unit value (1 byte, always 0)
| `b` | bool | Boolean (1 byte, `uint8_t`)
| `i1` | int8 | Signed 8-bit integer
| `i2` | int16 | Signed 16-bit integer
| `i4` | int32 | Signed 32-bit integer
| `i8` | int64 | Signed 64-bit integer
| `u1` | uint8 | Unsigned 8-bit integer
| `u2` | uint16 | Unsigned 16-bit integer
| `u4` | uint32 | Unsigned 32-bit integer
| `u8` | uint64 | Unsigned 64-bit integer
| `f4` | float32 | IEEE 754 single-precision float
| `f8` | float64 | IEEE 754 double-precision float
| `s` | string | Variable-length UTF-8 string
|===

Compound schemas prefix their element schemas:

[cols="1, 4"]
|===
| Pattern | Description

| `a<elem>` | Array of elements. Example: `ai4` = array of int32.
| `t<N><elem1><elem2>...` | Tuple with N elements. Example: `t2i4f8` = tuple of (int32, float64).
| `m<N><<klen>>key1<schema1><<klen>>key2<schema2>...` | Record (map) with N fields. Keys are length-prefixed strings. Example: `m2<3>agei4<4>names` = record with `age: int32` and `name: string`.
|===

The `Schema` struct in C captures this information:

[source,c]
----
typedef struct Schema {
    morloc_serial_type type;   // MORLOC_BOOL, MORLOC_ARRAY, etc.
    size_t size;               // number of parameters (tuple/record arity)
    size_t width;              // bytes in the voidstar representation
    size_t* offsets;           // byte offsets for tuple/record fields
    char* hint;                // optional type hint
    struct Schema** parameters; // child schemas (array element, tuple fields, etc.)
    char** keys;               // field names (records only)
} Schema;
----


==== The voidstar format

"Voidstar" is Morloc's native in-memory binary representation. It's designed
for zero-copy sharing through shared memory -- data is written once and read
directly by any process that maps the same shared memory volume.

**Primitives** are stored directly at their natural width:

* `bool` -> 1 byte (`uint8_t`, 0 or 1)
* `int32` -> 4 bytes (native endianness)
* `float64` -> 8 bytes (IEEE 754)

**Strings and arrays** use the `Array` struct:

[source,c]
----
typedef struct Array {
    size_t size;    // number of elements (or bytes for strings)
    relptr_t data;  // relative pointer to the actual data in shared memory
} Array;
----

For strings, `size` is the byte length and `data` points to the UTF-8 bytes
(no null terminator). For arrays, `size` is the element count and `data` points
to a contiguous block of `size * element_width` bytes.

**Tuples and records** are stored as flat structs with fields at
schema-defined offsets. Each field is stored at `base + schema->offsets[i]`.
Fixed-width fields (primitives, nested tuples) are inline; variable-width
fields (strings, arrays) are stored as `Array` structs containing relative
pointers to the actual data.

For example, a record `{name: Str, age: Int}` with schema `m2<4>namesi4<3>agei4`
would be laid out as:

----
offset 0:  Array { size, data }   -- name (string)
offset 16: int32_t                -- age
----

The `width` field in the schema gives the total size of the inline portion
(here, `sizeof(Array) + sizeof(int32_t) = 20 bytes`). The string's character
data lives elsewhere in shared memory, pointed to by the `Array.data` field.


==== MessagePack serialization

MessagePack is used as an interchange format in two situations:

1. **CLI argument parsing**: The nexus parses JSON arguments from the command
   line, converts them to voidstar (in shared memory), and packs them into call
   packets.
2. **File-based transfer**: When shared memory isn't available (e.g., for
   remote execution), data is serialized to MessagePack and written to a file.
   The packet carries the file path.

Two functions handle the conversion:

* `pack_with_schema(voidstar, schema) -> msgpack bytes` -- Walks the voidstar
  data structure according to the schema, writing MessagePack tokens. For
  arrays, it follows the `relptr_t` to the data in shared memory. For
  tuples/records, it iterates over fields at their schema-defined offsets.

* `unpack_with_schema(msgpack bytes, schema) -> voidstar` -- Makes two passes
  over the MessagePack data. The first pass (`msg_size`) calculates the total
  allocation needed. The second pass allocates a single block via `shmalloc`
  and unpacks the data into it, following the schema structure. Variable-length
  data (strings, arrays) is placed after the fixed-width portion, and
  `relptr_t` pointers are set up to reference it.


==== Data flow

The following diagram shows how data moves through the system during a typical
function call:

[mermaid]
....
flowchart LR
    A["CLI args<br/>(JSON strings)"] -->|parse + unpack| B["voidstar<br/>(in shared memory)"]
    B -->|"abs2rel"| C["relptr in<br/>call packet"]
    C -->|"Unix socket"| D["Pool receives<br/>call packet"]
    D -->|"rel2abs"| E["voidstar<br/>(same shared memory)"]
    E -->|"fromAnything"| F["Native type<br/>(e.g. std::vector)"]
    F -->|"user function"| G["Native result"]
    G -->|"toAnything"| H["voidstar<br/>(in shared memory)"]
    H -->|"abs2rel"| I["relptr in<br/>data packet"]
    I -->|"Unix socket"| J["Nexus receives<br/>data packet"]
    J -->|"rel2abs"| K["voidstar<br/>(same shared memory)"]
    K -->|"print_voidstar"| L["JSON output<br/>(stdout)"]
....

Key points:

* **No serialization on the hot path.** When both the nexus and pool share
  memory (the common case), data is never serialized or copied -- only 8-byte
  relative pointers move over the socket.
* **Serialization happens at boundaries.** JSON parsing (CLI input) and JSON
  printing (CLI output) are the only serialization steps for a local call. If a
  foreign call crosses a machine boundary, MessagePack serialization is used.
* **Each language has its own `fromAnything`/`toAnything`.** The {cpp} pool uses
  template-based conversion; Python and R use C extension modules that walk the
  schema and build native objects.
