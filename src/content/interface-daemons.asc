
=== Building API interfaces

In addition to being CLI tools, compiled Morloc programs can run as long-lived
daemons, accepting function calls over HTTP, TCP, or Unix sockets. A router
aggregates multiple programs behind a single API.

No extra steps are needed to setup these extra APIs. The are already built into
the executable we created in the last session. We only need to activate them.

==== HTTP protocol

We can start `dnd` as a daemon on HTTP port 8080:

[source,console]
----
$ dnd --daemon --http-port 8080 &
daemon: listening on http port 8080
daemon: ready
----

The trailing `&` creates the process in the background.

We can check the daemon's health:

[source,bash]
----
$ curl -s localhost:8080/health
{"status":"ok"}
----

The running daemons are discoverable:

[source,console]
----
$ curl -s localhost:8080/discover | jq .
{
  "status": "ok",
  "result": {
    "name": "dnd",
    "version": 1,
    "commands": [
      {
        "name": "rollAdv",
        "type": "remote",
        "return_type": "Int",
        "return_schema": "<int>i4",
        "args": [],
        "desc": "Roll a pair of d20 dice and keep the larger result"
      },
      {
        "name": "knightDamage",
        "type": "remote",
        "return_type": "Int",
        "return_schema": "<int>i4",
        "args": [
          {
            "kind": "pos",
            "type": "Int",
            "schema": "<int>i4"
          }
        ],
        "desc": "A knights damage"
      },
      {
        "name": "randomClass",
        "type": "remote",
        "return_type": "Str",
        "return_schema": "<str>s",
        "args": [],
        "desc": "Select a random class"
      },
      {
        "name": "randomRace",
        "type": "remote",
        "return_type": "Str",
        "return_schema": "<str>s",
        "args": [],
        "desc": "Select a random race"
      }
    ]
  }
}
----

Functions can be called over the port:

[source,console]
----
$ curl -s -X POST localhost:8080/call/randomClass -d '[]'
{"status":"ok","result":"Ranger"}

$ curl -s -X POST localhost:8080/call/knightDamage -d '[5]'
{"status":"ok","result":16}
----

Bad commands will return sensible errors:

[source,bash]
----
$ curl -s -X POST localhost:8080/call/fireball -d '[]'
{"status":"error","error":"Unknown command: fireball"}
----


==== TCP protocol

If HTTP isn't your tankard of ale, you can start a TCP port:

[source,bash]
----
$ ./tavern --daemon --port 9001
daemon: listening on tcp port 9001
daemon: ready
----


==== Unix Socket Protocol

The fastest way to make a local call to a process on a UNIX machine is over a
socket. This is how Morloc programs communicate internally.

To start a daemon on a Unix socket do the following:

[source,bash]
----
$ ./tavern --daemon --socket /tmp/tavern.sock
daemon: listening on unix socket /tmp/tavern.sock
daemon: ready
----

The socket protocol uses length-prefixed JSON: a 4-byte big-endian message
length followed by the JSON payload. Request and response share the same
framing.

[source,python]
.client.py -- minimal socket client
----
import socket, struct, json

def call(sock_path, method, command=None, args=None):
    msg = {"method": method}
    if command: msg["command"] = command
    if args is not None: msg["args"] = args

    payload = json.dumps(msg).encode()
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(sock_path)
    s.sendall(struct.pack('>I', len(payload)) + payload)

    resp_len = struct.unpack('>I', s.recv(4))[0]
    resp = s.recv(resp_len)
    s.close()
    return json.loads(resp)

print(call("/tmp/tavern.sock", "call", "rollD20"))
# {"status": "ok", "result": 18}

print(call("/tmp/tavern.sock", "call", "rollDice", [4, 6]))
# {"status": "ok", "result": [2, 5, 3, 1]}

print(call("/tmp/tavern.sock", "discover"))
# {"name": "tavern", "commands": [...]}
----

==== You can run all at once

You don't have to choose, one Morloc program can run all three protocols:

[source,bash]
----
$ ./tavern --daemon \
    --http-port 8080 \
    --port 9001 \
    --socket /tmp/tavern.sock
daemon: listening on unix socket /tmp/tavern.sock
daemon: listening on tcp port 9001
daemon: listening on http port 8080
daemon: ready
----

All three protocols hit the same daemon and share the same pool processes.

Router Mode

The router aggregates multiple morloc programs behind a single HTTP API.
Each program is discovered from a manifest file in the `fdb/` directory.

Setup

Install both programs so their manifests land in `fdb/`:

[source,bash]
----
$ morloc make --install -o tavern tavern.loc
Installed 'tavern' to ~/.local/share/morloc/bin/tavern

$ morloc make --install -o combat combat.loc
Installed 'combat' to ~/.local/share/morloc/bin/combat

$ ls ~/.local/share/morloc/fdb/
combat.manifest  tavern.manifest
----

Start the Router

[source,bash]
----
$ mim --router --http-port 9090
router: listening on http port 9090
router: 2 programs registered
router:   - combat (3 commands)
router:   - tavern (4 commands)
router: ready
----

List Programs

[source,bash]
----
$ curl -s localhost:9090/programs | python3 -m json.tool
{
    "programs": [
        {
            "name": "combat",
            "running": false,
            "commands": [
                {"name": "attackRoll", "type": "remote", "return_type": "Int"},
                {"name": "damage",     "type": "remote", "return_type": "Int"},
                {"name": "maxHp",      "type": "remote", "return_type": "Int"}
            ]
        },
        {
            "name": "tavern",
            "running": false,
            "commands": [
                {"name": "rollD20",      "type": "remote", "return_type": "Int"},
                {"name": "rollDice",     "type": "remote", "return_type": "[Int]"},
                {"name": "randomClass",  "type": "remote", "return_type": "Str"},
                {"name": "tavernGreet",  "type": "remote", "return_type": "Str"}
            ]
        }
    ]
}
----

Programs start lazily -- `running: false` until the first call.

Per-Program Discovery

[source,bash]
----
$ curl -s localhost:9090/discover/dnd | python3 -m json.tool
{
    "name": "dnd",
    "commands": [...]
}
----

Cross-Program Calls

Calls are routed by program name in the URL: `/call/<program>/<command>`.

[source,bash]
----
$ curl -s -X POST localhost:9090/call/tavern/rollD20 -d '[]'
{"status":"ok","result":19}

$ curl -s -X POST localhost:9090/call/tavern/rollDice -d '[3, 6]'
{"status":"ok","result":[4,2,6]}

$ curl -s -X POST localhost:9090/call/combat/attackRoll -d '[14, 3]'
{"status":"ok","result":17}

$ curl -s -X POST localhost:9090/call/combat/damage -d '[8, 2]'
{"status":"ok","result":16}

$ curl -s -X POST localhost:9090/call/combat/maxHp -d '[4, 10]'
{"status":"ok","result":50}
----

After the first call, the router auto-starts each program's daemon. Subsequent
calls reuse the running daemon with no startup cost.

Unknown Program

[source,bash]
----
$ curl -s -X POST localhost:9090/call/dungeon/explore -d '[]'
{"status":"error","error":"Unknown program: dungeon"}
----

Shutdown

Send `SIGTERM` to stop a daemon or router gracefully. Pool processes are
terminated, Unix socket files are removed, and child daemons (in router mode)
are cleaned up.

[source,bash]
----
$ kill $DAEMON_PID
daemon: shutting down

$ kill $ROUTER_PID
router: shutting down
----

Summary

[cols="1,1,3"]
|===
| Mode | Flag | Description

| Daemon
| `--daemon`
| Run one program as a persistent service

| Router
| `--router`
| Aggregate all installed programs (`fdb/`) behind one API

| HTTP
| `--http-port <n>`
| RESTful JSON API (curl-friendly)

| TCP
| `--port <n>`
| Length-prefixed JSON over TCP

| Socket
| `--socket <path>`
| Length-prefixed JSON over Unix socket

| fdb
| `--fdb <path>`
| Override manifest directory (default: `~/.local/share/morloc/fdb`)
|===


