
=== Building API interfaces

In addition to being CLI tools, compiled Morloc programs can run as long-lived
daemons, accepting function calls over HTTP, TCP, or Unix sockets. A router
aggregates multiple programs behind a single API.

No extra steps are needed to setup these extra APIs. They are already built into
the executable we created in the last session. We only need to activate them.

==== HTTP protocol

We can start `combat` as a daemon on HTTP port 8080:

[source,console]
----
$ combat --daemon --http-port 8080 &
daemon: listening on http port 8080
daemon: ready
----

The trailing `&` creates the process in the background. This command launches
all language pool processes (Python and R in this case) as child processes in
separate process groups. A thread pool handles concurrent requests. If a pool
crashes, the daemon detects it restarts it automatically.

We can check the daemon's health:

[source,bash]
----
$ curl -s localhost:8080/health
{"status":"ok","result":[true]}
----

The /health endpoint returns the liveness status of each pool.

The running daemons are discoverable:

[source,console]
----
$ curl -s localhost:8080/discover | jq .
{
  "status": "ok",
  "result": {
    "name": "combat",
    "version": 1,
    "commands": [
      {
        "name": "rollAdv",
        "type": "remote",
        "return_type": "Int",
        "return_schema": "<int>i4",
        "args": [],
        "desc": "Roll a pair of d20 dice and keep the larger result"
      },
      {
        "name": "fighterDamage",
        "type": "remote",
        "return_type": "Int",
        "return_schema": "<int>i4",
        "args": [
          {
            "kind": "pos",
            "type": "Int",
            "schema": "<int>i4"
          }
        ],
        "desc": "Damage calculation for a fighter"
      },
      {
        "name": "threeHits",
        "type": "remote",
        "return_type": "[Int]",
        "return_schema": "<array><int>i4",
        "args": [
          {
            "kind": "pos",
            "type": "Int",
            "schema": "<int>i4"
          }
        ],
        "desc": "Three hit rolls against an enemy"
      },
      {
        "name": "intro",
        "type": "remote",
        "return_type": "Str",
        "return_schema": "<str>s",
        "args": [
          {
            "kind": "pos",
            "type": "Str",
            "schema": "<str>s"
          }
        ],
        "desc": "Introduce a new battle!"
      }
    ]
  }
}
----

Functions can be called over the port:

[source,console]
----
$ curl -s -X POST localhost:8080/call/rollAdv -d '[]'
{"status":"ok","result":18}

$ curl -s -X POST localhost:8080/call/fighterDamage -d '[15]'
{"status":"ok","result":12}
----

Bad commands will return sensible errors:

[source,bash]
----
$ curl -s -X POST localhost:8080/call/fireball -d '[]'
{"status":"error","error":"Unknown command: fireball"}
----

// HTTP implementation notes:
//  - Supports CORS preflight (OPTIONS on any path) with Access-Control-Allow-Origin: *
//  - POST body can be a raw JSON array: [arg1, arg2] or an object: {"args": [arg1, arg2]}
//  - Connection: close is sent on every response (no keep-alive)
//  - Content-Type is always application/json

==== TCP protocol

HTTP adds overhead per request: headers, text parsing, and the full HTTP framing
around each message. When your client is a program rather than a browser or
`curl`, you can skip all of that. The TCP protocol uses a compact binary framing
-- just a 4-byte big-endian length prefix followed by the JSON payload. This
makes it well suited for service-to-service communication, high-throughput
automated pipelines, or any context where you control both ends of the
connection and want minimal overhead.

Start a daemon on TCP port 9001:

[source,bash]
----
$ combat --daemon --port 9001 &
daemon: listening on tcp port 9001
daemon: ready
----

Unlike the HTTP protocol, you can't use `curl` to talk to a TCP daemon. You need
a client that speaks the length-prefixed binary framing. Here is a minimal
Python client:

[source,python]
.tcp_client.py -- minimal TCP client
----
import socket, struct, json

def call(host, port, method, command=None, args=None):
    msg = {"method": method}
    if command: msg["command"] = command
    if args is not None: msg["args"] = args

    payload = json.dumps(msg).encode()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    # send 4-byte big-endian length, then the JSON payload
    s.sendall(struct.pack('>I', len(payload)) + payload)

    # read the 4-byte response length, then the response
    resp_len = struct.unpack('>I', s.recv(4))[0]
    resp = s.recv(resp_len)
    s.close()
    return json.loads(resp)

print(call("localhost", 9001, "call", "rollAdv"))
# {"status": "ok", "result": 18}

print(call("localhost", 9001, "call", "fighterDamage", [15]))
# {"status": "ok", "result": 12}

print(call("localhost", 9001, "health"))
# {"status": "ok", "result": [true]}

print(call("localhost", 9001, "discover"))
# {"status": "ok", "result": {"name": "combat", "commands": [...]}}
----

The request is a JSON object with a `method` field (`"call"`, `"discover"`, or
`"health"`), an optional `command` field naming the function, and an optional
`args` array.

// TCP protocol note: the length prefix is encoded as 4 bytes, big-endian
// (network byte order), unsigned 32-bit integer. The request JSON has an
// optional "id" field; if provided, the response echoes it back. This is
// useful for multiplexing requests over a single connection, though the
// current server handles one request per connection.


==== Unix socket protocol

// Technical detail: the framing is identical for TCP and Unix sockets --
// both use 4-byte big-endian length prefix + JSON. Max message size is 64 MB.
// Socket timeout is 30 seconds per operation.

For processes running on the same machine, Unix domain sockets are the fastest
option. They bypass the entire network stack -- no TCP handshake, no port
allocation, no loopback routing. This is how Morloc pools communicate with the
nexus internally.

To start a daemon on a Unix socket:

[source,bash]
----
$ combat --daemon --socket /tmp/combat.sock &
daemon: listening on unix socket /tmp/combat.sock
daemon: ready
----

The wire protocol is identical to TCP: a 4-byte big-endian length prefix
followed by the JSON payload. The only difference is the socket type.

[source,python]
.unix_client.py -- minimal socket client
----
import socket, struct, json

def call(sock_path, method, command=None, args=None):
    msg = {"method": method}
    if command: msg["command"] = command
    if args is not None: msg["args"] = args

    payload = json.dumps(msg).encode()
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(sock_path)
    s.sendall(struct.pack('>I', len(payload)) + payload)

    resp_len = struct.unpack('>I', s.recv(4))[0]
    resp = s.recv(resp_len)
    s.close()
    return json.loads(resp)

print(call("/tmp/combat.sock", "call", "rollAdv"))
# {"status": "ok", "result": 18}

print(call("/tmp/combat.sock", "call", "fighterDamage", [15]))
# {"status": "ok", "result": 12}

print(call("/tmp/combat.sock", "discover"))
# {"status": "ok", "result": {"name": "combat", "commands": [...]}}
----


==== Running all protocols at once

You don't have to choose. One daemon can listen through all three protocols at
the same time:

[source,bash]
----
$ combat --daemon \
      --http-port 8080 \
      --port 9001 \
      --socket /tmp/combat.sock
daemon: listening on unix socket /tmp/combat.sock
daemon: listening on tcp port 9001
daemon: listening on http port 8080
daemon: ready
----

All three protocols hit the same daemon process and share the same pool
processes. A request arriving over HTTP, TCP, or the Unix socket is dispatched
identically -- only the framing differs.

==== From single daemons to a router

Everything above shows a single program running as a daemon. This is enough when
you have one service, but Morloc programs are designed to be composed. You might
have a `tavern` program that picks character classes and races, and a
`combat` program that resolves attacks and damage. Each is its own compiled
Morloc program with its own pools.

You _could_ start each one as an independent daemon on its own port and have
your client keep track of which port maps to which program. But that gets
tedious. The router solves this: it presents a single HTTP endpoint that
discovers and manages all your installed Morloc programs.

// Architecture overview:
//
// The relationship between the router, daemons, and pools:
//
//   Client (curl, browser, code)
//     |
//     | HTTP request: POST /call/tavern/randomClass
//     v
//   +------------------+
//   |     Router       |   (morloc-nexus --router --http-port 9090)
//   |   HTTP server    |   Listens on HTTP (and optionally TCP/socket).
//   |   on port 9090   |   Reads manifests from fdb/ at startup.
//   +------------------+
//     |             |
//     | Unix socket | Unix socket
//     v             v
//   +--------+   +--------+
//   | tavern |   | combat |     Each is a full daemon (morloc-nexus <manifest> --daemon)
//   | daemon |   | daemon |     started as a child process by the router.
//   +--------+   +--------+
//    |  |  |      |  |  |
//    v  v  v      v  v  v
//   pools         pools          Language runtime processes (Python, C++, R, ...)
//
// The router forks each daemon as a child process in its own process group.
// Communication between router and daemon uses Unix sockets with the
// length-prefixed JSON protocol. The client never talks to daemons directly
// -- all requests flow through the router's HTTP interface.
//
// Programs are started lazily: the router only forks a daemon when the first
// request arrives for that program. If a daemon crashes, the router detects
// the failure on the next request and restarts it automatically.

The following diagram illustrates how a client request flows through the router
to a program daemon and its language pools:

....
                  Client
                    |
                    | HTTP: POST /call/tavern/randomClass -d '[]'
                    v
             +--------------+
             |    Router    |  morloc-nexus --router --http-port 9090
             |  (HTTP:9090) |  Reads manifests from fdb/ at startup
             +--------------+
              /            \
    Unix socket            Unix socket
            /                \
  +-----------+         +-----------+
  |  tavern   |         |  combat   |
  |  daemon   |         |  daemon   |
  +-----------+         +-----------+
       |                 /        \
       v                v          v
    Python           Python        R
     pool             pool        pool
....

Each daemon is a child process of the router, started lazily on first request.
The router and its daemons communicate over Unix sockets using the same
length-prefixed JSON protocol described above.


==== Router mode

===== Setup

To make a program available to the router, install it with `--install`. This
copies the program binary and writes a manifest file to the `fdb/` directory
where the router discovers programs at startup.

// Technical detail: `morloc make --install` builds the program normally, then
// copies the binary to ~/.local/share/morloc/bin/<name> and extracts the
// manifest JSON into ~/.local/share/morloc/fdb/<name>.manifest. The manifest
// contains pool definitions, command signatures, and serialization schemas.

[source,bash]
----
$ morloc make --install -o tavern tavern.loc
Installed 'tavern' to ~/.local/share/morloc/bin/tavern

$ morloc make --install -o combat combat.loc
Installed 'combat' to ~/.local/share/morloc/bin/combat

$ ls ~/.local/share/morloc/fdb/
combat.manifest  tavern.manifest
----

===== Starting the router

[source,bash]
----
$ mim --router --http-port 9090
router: listening on http port 9090
router: 2 programs registered
router:   - combat (4 commands)
router:   - tavern (2 commands)
router: ready
----

// The router scans the fdb/ directory for .manifest files at startup, parses
// each one, and registers the program. It does NOT start any daemons yet --
// programs are started lazily on first call. Each daemon gets a Unix socket
// at /tmp/morloc-router-<program-name>.sock for router-daemon communication.

===== Listing programs

[source,bash]
----
$ curl -s localhost:9090/programs | python3 -m json.tool
{
    "programs": [
        {
            "name": "combat",
            "running": false,
            "commands": [
                {"name": "rollAdv",        "type": "remote", "return_type": "Int"},
                {"name": "fighterDamage",  "type": "remote", "return_type": "Int"},
                {"name": "threeHits",      "type": "remote", "return_type": "[Int]"},
                {"name": "intro",          "type": "remote", "return_type": "Str"}
            ]
        },
        {
            "name": "tavern",
            "running": false,
            "commands": [
                {"name": "randomClass",  "type": "remote", "return_type": "Str"},
                {"name": "randomRace",   "type": "remote", "return_type": "Str"}
            ]
        }
    ]
}
----

Programs start lazily -- `running: false` until the first call.

===== Per-program discovery

You can discover commands for a specific program without starting its daemon:

[source,bash]
----
$ curl -s localhost:9090/discover/tavern | python3 -m json.tool
{
    "name": "tavern",
    "commands": [...]
}
----

// Note: per-program discovery (/discover/<program>) reads directly from the
// parsed manifest -- no daemon is started. The top-level /discover endpoint
// returns combined discovery for all registered programs.

===== Calling functions

Calls are routed by program name in the URL: `/call/<program>/<command>`.

[source,bash]
----
$ curl -s -X POST localhost:9090/call/tavern/randomClass -d '[]'
{"status":"ok","result":"Rogue"}

$ curl -s -X POST localhost:9090/call/tavern/randomRace -d '[]'
{"status":"ok","result":"Elf"}

$ curl -s -X POST localhost:9090/call/combat/rollAdv -d '[]'
{"status":"ok","result":17}

$ curl -s -X POST localhost:9090/call/combat/fighterDamage -d '[15]'
{"status":"ok","result":12}

$ curl -s -X POST localhost:9090/call/combat/intro -d '["Goblin"]'
{"status":"ok","result":"A wild Goblin appears!"}
----

The first call to a program starts its daemon automatically. Subsequent calls
reuse the running daemon with no startup cost. If a daemon crashes between
calls, the router detects the failure and restarts it transparently.

===== Error handling

[source,bash]
----
$ curl -s -X POST localhost:9090/call/dungeon/explore -d '[]'
{"status":"error","error":"Unknown program: dungeon"}
----

===== Independent daemons vs router-managed daemons

A daemon started manually (e.g., `combat --daemon --http-port 8080`) is completely
independent of the router. The router only knows about programs whose manifests
are in the `fdb/` directory, and it starts its own daemon instances as child
processes. If you start a daemon on your own and also have the same program
registered with the router, you will have two separate daemon processes -- each
with its own pool processes and its own state.

// Implementation detail: the router starts each daemon with:
//   mim <manifest-path> --daemon --socket /tmp/morloc-router-<name>.sock
// The daemon runs in its own process group (via setpgid). The router tracks
// the PID and can detect crashes via waitpid(WNOHANG). There is no API to
// stop an individual daemon through the router -- the router manages daemon
// lifecycles automatically. All daemons are terminated when the router shuts
// down.


==== Shutdown

Send `SIGTERM` (or `SIGINT`) to stop a daemon or router gracefully. The daemon
sends `SIGTERM` to each pool process group, waits briefly for clean exit, then
sends `SIGKILL` to any stragglers. Unix socket files are removed.

[source,bash]
----
$ kill $DAEMON_PID
daemon: shutting down

$ kill $ROUTER_PID
router: shutting down
----

When a router shuts down, it terminates all the daemons it started. There is
currently no way to stop an individual program's daemon through the router API
-- the router manages their lifecycles internally. If you need to restart a
specific program, restart the router.

// Shutdown sequence details:
//  1. Signal handler sets shutdown_requested flag
//  2. Worker threads finish current requests and exit
//  3. SIGCHLD is blocked during cleanup to avoid races
//  4. SIGTERM sent to each pool process group
//  5. Wait up to 500ms per group for graceful exit
//  6. SIGKILL sent to any remaining processes
//  7. Shared memory and temp directories cleaned up
//  8. Unix socket files unlinked


==== Summary

[cols="1,1,3"]
|===
| Mode | Flag | Description

| Daemon
| `--daemon`
| Run one program as a persistent service

| Router
| `--router`
| Aggregate all installed programs (`fdb/`) behind one API

| HTTP
| `--http-port <n>`
| RESTful JSON API (curl-friendly)

| TCP
| `--port <n>`
| Length-prefixed JSON over TCP

| Socket
| `--socket <path>`
| Length-prefixed JSON over Unix socket

| fdb
| `--fdb <path>`
| Override manifest directory (default: `~/.local/share/morloc/fdb`)
|===
