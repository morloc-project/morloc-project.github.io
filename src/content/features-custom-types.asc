=== Defining non-primitive types

Types that are composed entirely of Morloc primitives, lists, tuples, records
and tables may be directly and unambiguously translated to Morloc binary forms
and thus shared between languages. But what about types that do not break down
cleanly into these forms? For example, consider the parameterized `Map k v` type
that represents a collection with keys of generic type `k` and values of generic
type `v`. This type may have many representations, including a list of pairs, a
pair of columns, a binary tree, and a hashmap. In order for Morloc to know how
to convert all `Map` types in all languages to one form, it must know how to
express `Map` type in terms of more primitive types. The user can provide this
information by defining instances of the `Packable` typeclass for `Map`. This
typeclass defines two functions, `pack` and `unpack`, that construct and
deconstruct a complex type.

[source, morloc]
----
class Packable a b where
    pack a b :: a -> b
    unpack a b :: b -> a
----

The `Map` type for Python and {cpp} may be defined as follows:

[source, morloc]
----
type Py => Map key val = "dict" key val
type Cpp => Map key val = "std::map<$1,$2>" key val
instance Packable ([a],[b]) (Map a b) where
    source Cpp from "map-packing.hpp" ("pack", "unpack")
    source Py from "map-packing.py" ("pack", "unpack")
----

The Morloc user never needs to directly apply the `pack` and `unpack`
functions. Rather, these are used by the compiler within the generated code. The
compiler constructs a serialization tree from the general type and from this
trees generates the native code needed to (un)pack types recursively until only
primitive types remain. These may then be directly translated to Morloc binary
using the language-specific binding libraries.

In some cases, the native type may not be as generic as the general type. Or you
may want to add specialized (un)packers. In such cases, you can define more
specialized instances of `Packable`. For example, if the `R` `Map` type is
defined as an `R` list, then keys can only be strings. Any other type should
raise an error. So we can write:

[source, morloc]
----
type R => Map key val = "list" key val
instance Packable ([Str],[b]) (Map Str b) where
source R from "map-packing.R" ("pack", "unpack")
----

Now whenever the key generic type of `Map` is inferred to be anything other than
a string, all R implementations will be pruned.
