=== Daemons

Morloc programs can run as long-lived daemons, accepting function calls over
HTTP, TCP, or Unix sockets. A router aggregates multiple programs behind a
single API.

Let's start by defining the Morloc programs.

[source,morloc]
----
-- tavern.loc: Python-backed character utilities
import root-py

source Py from "tavern.py"
  ( "roll_dice" as rollDice
  , "roll_d20" as rollD20 
  , "random_class" as randomClass
  , "tavern_greet" as tavernGreet
  )

--' Roll n d-sided dice
rollDice :: 
  --' Number of dice
  Int ->
  --' Number of pips per die
  Int ->
  --' Roll values
  {[Int]}

--' Directly roll a single d20
rollD20 :: {Int}

--' Generate a greeting
tavernGreet ::
  --' Player name
  --' literal: true
  Str ->
  Str

--' Generate a random class
randomClass :: {Str}

--' Roll a D20
rollAdv :: Int
rollAdv = fold max 0 !(rollDice 2 20)
----

[source,python]
.tavern.py
----
import random

def roll_d20():
    return random.randint(1, 20)

def roll_dice(n, sides):
    return [random.randint(1, sides) for _ in range(n)]

def random_class():
    classes = ["Fighter", "Wizard", "Rogue", "Cleric", "Ranger", "Bard"]
    return random.choice(classes)

def tavern_greet(name):
    return "Hail, " + name + "! Pull up a chair."
----

[source,morloc]
----
-- combat.loc: C++ combat math
module combat (attackRoll, damage, maxHp)

import root-cpp

source Cpp from "combat.hpp" ("attack_roll", "damage", "max_hp")

attackRoll :: Int -> Int -> Int
damage :: Int -> Int -> Int
maxHp :: Int -> Int -> Int
----

[source,cpp]
.combat.hpp
----
#include <algorithm>

int attack_roll(int roll, int modifier) {
    return std::min(roll + modifier, 30);
}

int damage(int base, int multiplier) {
    return base * multiplier;
}

int max_hp(int constitution, int level) {
    return 10 + constitution * level;
}
----

Build

[source,bash]
----
$ morloc make -o tavern tavern.loc
$ morloc make -o combat combat.loc
----

Verify they work in CLI mode first:

[source,bash]
----
$ ./tavern rollD20
17
$ ./tavern tavernGreet "Gandalf"
"Hail, Gandalf! Pull up a chair."
$ ./combat maxHp 3 5
25
----

Daemon Mode

Start `tavern` as a daemon on HTTP port 8080:

[source,bash]
----
$ ./tavern --daemon --http-port 8080
daemon: listening on http port 8080
daemon: ready
----

Health Check

[source,bash]
----
$ curl -s localhost:8080/health
{"status":"ok","result":{"status":"ok"}}
----

API Discovery

[source,bash]
----
$ curl -s localhost:8080/discover | python3 -m json.tool
{
    "name": "tavern",
    "commands": [
        {
            "name": "rollD20",
            "type": "remote",
            "return_type": "Int",
            "args": []
        },
        {
            "name": "rollDice",
            "type": "remote",
            "return_type": "[Int]",
            "args": [
                {"type": "Int"},
                {"type": "Int"}
            ]
        },
        {
            "name": "randomClass",
            "type": "remote",
            "return_type": "Str",
            "args": []
        },
        {
            "name": "tavernGreet",
            "type": "remote",
            "return_type": "Str",
            "args": [
                {"type": "Str"}
            ]
        }
    ]
}
----

Calling Functions over HTTP

No-argument calls:

[source,bash]
----
$ curl -s -X POST localhost:8080/call/rollD20 -d '[]'
{"status":"ok","result":14}

$ curl -s -X POST localhost:8080/call/randomClass -d '[]'
{"status":"ok","result":"Rogue"}
----

With arguments:

[source,bash]
----
$ curl -s -X POST localhost:8080/call/rollDice \
    -H 'Content-Type: application/json' \
    -d '[4, 6]'
{"status":"ok","result":[3,5,1,6]}

$ curl -s -X POST localhost:8080/call/tavernGreet \
    -H 'Content-Type: application/json' \
    -d '["Legolas"]'
{"status":"ok","result":"Hail, Legolas! Pull up a chair."}
----

Arguments can also be wrapped in an object:

[source,bash]
----
$ curl -s -X POST localhost:8080/call/rollDice \
    -d '{"args": [3, 8]}'
{"status":"ok","result":[7,2,5]}
----

Error Handling

Unknown command:

[source,bash]
----
$ curl -s -X POST localhost:8080/call/fireball -d '[]'
{"status":"error","error":"Unknown command: fireball"}
----

Unix Socket Protocol

Start a daemon on a Unix socket instead of (or in addition to) HTTP:

[source,bash]
----
$ ./tavern --daemon --socket /tmp/tavern.sock
daemon: listening on unix socket /tmp/tavern.sock
daemon: ready
----

The socket protocol uses length-prefixed JSON: a 4-byte big-endian message
length followed by the JSON payload. Request and response share the same
framing.

[source,python]
.client.py -- minimal socket client
----
import socket, struct, json

def call(sock_path, method, command=None, args=None):
    msg = {"method": method}
    if command: msg["command"] = command
    if args is not None: msg["args"] = args

    payload = json.dumps(msg).encode()
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(sock_path)
    s.sendall(struct.pack('>I', len(payload)) + payload)

    resp_len = struct.unpack('>I', s.recv(4))[0]
    resp = s.recv(resp_len)
    s.close()
    return json.loads(resp)

print(call("/tmp/tavern.sock", "call", "rollD20"))
# {"status": "ok", "result": 18}

print(call("/tmp/tavern.sock", "call", "rollDice", [4, 6]))
# {"status": "ok", "result": [2, 5, 3, 1]}

print(call("/tmp/tavern.sock", "discover"))
# {"name": "tavern", "commands": [...]}
----

TCP Protocol

TCP uses the same length-prefixed JSON protocol, but over a TCP port:

[source,bash]
----
$ ./tavern --daemon --port 9001
daemon: listening on tcp port 9001
daemon: ready
----

Any TCP client can connect to `127.0.0.1:9001` and use the same
`struct.pack('>I', len) + json` framing.

All Three Listeners at Once

[source,bash]
----
$ ./tavern --daemon \
    --http-port 8080 \
    --port 9001 \
    --socket /tmp/tavern.sock
daemon: listening on unix socket /tmp/tavern.sock
daemon: listening on tcp port 9001
daemon: listening on http port 8080
daemon: ready
----

All three protocols hit the same daemon and share the same pool processes.

Router Mode

The router aggregates multiple morloc programs behind a single HTTP API.
Each program is discovered from a manifest file in the `fdb/` directory.

Setup

Install both programs so their manifests land in `fdb/`:

[source,bash]
----
$ morloc make --install -o tavern tavern.loc
Installed 'tavern' to ~/.local/share/morloc/bin/tavern

$ morloc make --install -o combat combat.loc
Installed 'combat' to ~/.local/share/morloc/bin/combat

$ ls ~/.local/share/morloc/fdb/
combat.manifest  tavern.manifest
----

Start the Router

[source,bash]
----
$ mim --router --http-port 9090
router: listening on http port 9090
router: 2 programs registered
router:   - combat (3 commands)
router:   - tavern (4 commands)
router: ready
----

List Programs

[source,bash]
----
$ curl -s localhost:9090/programs | python3 -m json.tool
{
    "programs": [
        {
            "name": "combat",
            "running": false,
            "commands": [
                {"name": "attackRoll", "type": "remote", "return_type": "Int"},
                {"name": "damage",     "type": "remote", "return_type": "Int"},
                {"name": "maxHp",      "type": "remote", "return_type": "Int"}
            ]
        },
        {
            "name": "tavern",
            "running": false,
            "commands": [
                {"name": "rollD20",      "type": "remote", "return_type": "Int"},
                {"name": "rollDice",     "type": "remote", "return_type": "[Int]"},
                {"name": "randomClass",  "type": "remote", "return_type": "Str"},
                {"name": "tavernGreet",  "type": "remote", "return_type": "Str"}
            ]
        }
    ]
}
----

Programs start lazily -- `running: false` until the first call.

Per-Program Discovery

[source,bash]
----
$ curl -s localhost:9090/discover/tavern | python3 -m json.tool
{
    "name": "tavern",
    "commands": [...]
}
----

Cross-Program Calls

Calls are routed by program name in the URL: `/call/<program>/<command>`.

[source,bash]
----
$ curl -s -X POST localhost:9090/call/tavern/rollD20 -d '[]'
{"status":"ok","result":19}

$ curl -s -X POST localhost:9090/call/tavern/rollDice -d '[3, 6]'
{"status":"ok","result":[4,2,6]}

$ curl -s -X POST localhost:9090/call/combat/attackRoll -d '[14, 3]'
{"status":"ok","result":17}

$ curl -s -X POST localhost:9090/call/combat/damage -d '[8, 2]'
{"status":"ok","result":16}

$ curl -s -X POST localhost:9090/call/combat/maxHp -d '[4, 10]'
{"status":"ok","result":50}
----

After the first call, the router auto-starts each program's daemon. Subsequent
calls reuse the running daemon with no startup cost.

Unknown Program

[source,bash]
----
$ curl -s -X POST localhost:9090/call/dungeon/explore -d '[]'
{"status":"error","error":"Unknown program: dungeon"}
----

Shutdown

Send `SIGTERM` to stop a daemon or router gracefully. Pool processes are
terminated, Unix socket files are removed, and child daemons (in router mode)
are cleaned up.

[source,bash]
----
$ kill $DAEMON_PID
daemon: shutting down

$ kill $ROUTER_PID
router: shutting down
----

Summary

[cols="1,1,3"]
|===
| Mode | Flag | Description

| Daemon
| `--daemon`
| Run one program as a persistent service

| Router
| `--router`
| Aggregate all installed programs (`fdb/`) behind one API

| HTTP
| `--http-port <n>`
| RESTful JSON API (curl-friendly)

| TCP
| `--port <n>`
| Length-prefixed JSON over TCP

| Socket
| `--socket <path>`
| Length-prefixed JSON over Unix socket

| fdb
| `--fdb <path>`
| Override manifest directory (default: `~/.local/share/morloc/fdb`)
|===


