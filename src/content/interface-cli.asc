=== Modules and docstrings

A Morloc module describes a set of functions, their types, and their
descriptions. We've already covered terms and types, now we will cover the
descriptions we add to modules, functions, arguments and fields. The extra data
is stored in specialized comments (docstrings) that describe the terms and add
modifications like defaults. The most obvious use case of these annotations is
in specializing CLI interfaces, discussed in the next section, but they aslo
inform the generation of rich APIs as well (see the HTTP/TCP/socket section).

=== The Command Line Interface (CLI)

Building a Morloc module will generate a CLI tool where exported functions are
presented as typed subcommands.

Here is a minimal example of propagated function descriptions:

[source, morloc]
----
import root-py

source Py from "main.py" ("foo", "bar")

--' Take two reals and do thing
foo :: Real -> Real -> Real

--' Convert a list of reals into a thing
bar :: [Real] -> Real
----

The special comment `--'` introduces a docstring that is attached to the
following type signature and will be propagated through to the code generated by
the backend.

[source, console]
----
$ morloc make main.loc
$ ./neuxs -h
Usage: ./nexus [OPTION...] COMMAND [ARG...]

Nexus Options:
 -h, --help            Print this help message
 -o, --output-file     Print to this file instead of STDOUT
 -f, --output-format   Output format [json|mpk|voidstar]

Exported commands (call with -h/--help for more info):
  foo  Take two reals and do thing
  bar  Convert a list of reals into a thing
----

More detailed information about each exported subcommand may be accessed as well:

[source, console]
----
$ ./nexus foo -h
Usage: ./nexus foo ARG1 ARG2

Take two reals and do thing

Positional arguments:
  ARG1  No description given
        type: Real
  ARG2  No description given
        type: Real

Return: Real
----

Docstrings may also contain tags that specify how the arguments of the exported
functions map to CLI positional or optional arguments. Here is a list of the
currently supported tags:

 * `name` - give the CLI subcommand a dedicated name rather than defaulting to
   the Morloc function name 

 * `literal` - treat an argument the actual data, not a file that contains the
   data, currently this is just used for strings where `literal: true` indicates
   that the extra JSON quotes are not required.

 * `unroll` - if `true`, then the record argument is "unrolled" into a group of optional arguments

 * `default` - the default value for an argument, in JSON format

 * `metavar` - the variable name used for the argument in the usage text

 * `arg` - short and long labels for this argument (e.g., "-v/--verbose")

 * `true` - the flag labels that toggle a boolean argument on

 * `false` - the flag labels that toggle a boolean argument off

 * `return` - a description of the returned data (this tag is the same as adding a description docstring to final type in a signature)

Here is a longer example that show-cases these tags:

[source, morloc]
----
module foobar (foo, bar)

import root-py

source Py from "foobar.py"
  ("foo", "bar")

--' config record
--' unroll: true
--' arg: --config
record Config where
  --' temporary directory
  --' arg: --tmp
  --' literal: true
  --' default: "/tmp"
  tmpdir :: Str

  --' cache the results
  --' true: --cache
  cache :: Bool

  --' number of threads to use
  --' arg: -t/--num-threads
  --' default: 1
  nthreads :: Int

--' do foo stuff
foo ::
  Config ->
  --' list of integers
  --' metavar: INT_LIST
  [Int] ->
  --' sum of INT_LIST
  Int 

--' do bar stuff
--' return: summed values
bar ::
  --' unroll: false
  Config -> [Int] -> Int 
----

The top-level usage statement is as follows

[source, console]
----
$ ./nexus -h
Usage: ./nexus [OPTION...] COMMAND [ARG...]

Nexus Options:
 -h, --help            Print this help message
 -o, --output-file     Print to this file instead of STDOUT
 -f, --output-format   Output format [json|mpk|voidstar]

Exported commands (call with -h/--help for more info):
  foo  do foo stuff
  bar  do bar stuff
----

The dedicated usage information for `foo` can be accessed as well. Here we see
that the record `Config` has been unrolled into a group of optional arguments:

[source, console]
----
$ ./nexus foo -h
Usage: ./nexus foo [OPTION...] INT_LIST

do foo stuff

Positional arguments:
  INT_LIST  list of integers
            type: [Int]

Group arguments:
  Config: config record
    --config Config
        Default values for this argument group
            tmpdir :: Str
            cache :: Bool
            nthreads :: Int
    --tmp Str
        temporary directory
        type: Str
        default: "/tmp"
    --cache
        cache the results
        default: false
    -t Int, --num-threads Int
        number of threads to use
        type: Int
        default: 1

Return: Int
  sum of INT_LIST
----

Since each subcommand is a function, the return type is always the same. Unlike
in a conventional CLI program, the arguments cannot alter the return type.

The `bar` subcommand explicitly does not unroll the `Config` record:

[source, console]
----
$ ./nexus bar -h
Usage: ./nexus bar ARG1 ARG2

do bar stuff

Positional arguments:
  ARG1  config record
        type: NamRecord Config<>
              {
                  tmpdir :: Str
                  cache :: Bool
                  nthreads :: Int
              }
  ARG2  No description given
        type: [Int]

Return: Int
  summed values
----


=== Composing CLI Tools

Since modules can both be compiled into executable command line tools and
imported by other modules, we can naturally compose command line tools.

Here is a little Morloc script that imports a Python program that prints a calendar to STDERR.

[source, morloc]
----
module cally (cal)

import root-py

source Py from "cal.py" ("cal")

--' Print a 3-month calendar and some timezones
cal :: () -> ()
----

Here is another Morloc tool that prints d20 rolls

[source, morloc]
----
module dnd (d20)

import root-py

source R from "dnd.R" ("d20")

--' Roll n d20 dice
d20 :: Int -> [Int]
----

Now we can import both of these into a third module which will expose the
functions from both the calendar and dnd modules.

[source, morloc]
----
module toolbox (cal, d20)

import cally
import dnd
----

This final module can be compiled and will have a usage statement like so: 

----
Usage: ./nexus [OPTION]... COMMAND [ARG]...

Nexus Options:
 -h, --help            Print this help message
 -o, --output-file     Print to this file instead of STDOUT
 -f, --output-format   Output format [json|mpk|voidstar]

Exported Commands:
  cal   Print a 3-month calendar and some timezones
          return: Unit
  d20   Roll n d20 dice
          param 1: Int
          return: [Int]
----


=== User arguments and outputs

User data is passed to Morloc executables as positional arguments to the
specified function subcommand. The argument may be a literal JSON string or a
filename. For files, the format may be JSON, MessagePack, or Morloc binary (VoidStar)
format. The Morloc nexus first checks for a ".json" extension, if found, the
nexus attempts to parse the file as JSON. Next the nexus checks for a ".mpk" or
".msgpack" extension, and if found it attempts to parse the file as a
MessagePack file. If neither extension is found, it attempts to parse the file
first as Morloc binary, then as MessagePack, and finally as JSON. See the
`parse_cli_data_argument` function in `morloc.h` for details.

Passing literal JSON on the command line can be a little unintuitive since extra
quoting may be required. Here are a few examples:

[source, bash]
----
# The Bash shell removes the outer quotes, so double quoting is required
$ ./nexus foo '"this is a literal string"'

# Single quotes are lists is fine, still need to quote inner strings 
$ ./nexus bar '["asdf", "df"]'

# By default, output is written to JSON format
$ ./nexus baz 1 2 3 > baz.json

# The output can be directly read by a downstream morloc program
$ ./nexus bif baz.json
----

Data may be written to MessagePack or VoidStar via the `-f` argument:

[source, console]
----
$ ./nexus -f voidstar head '[["some","random"],["data"]]' > data.vs
$ ./nexus -f json head data.vs > data.json
$ ./nexus -f mpk reverse data.json > data.mpk
$ ./nexus reverse data.mpk
"some"
----

The VoidStar format is the richest and is the only form that contains the schema
describing the data.

