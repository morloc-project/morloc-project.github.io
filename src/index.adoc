= Morloc Technical Manual
:author: Zebulun Arendsee
:bibtex-file: references.bib
:bibtex-order: appearance
:bibtex-style: cambridge-university-press-numeric.csl
:docinfo: shared
:favicon: ./static/img/favicon.ico
:figure-caption!:
:icons: image
:iconsdir: ./static/img/admonition_icons
:imagesdir: ./static/img
:nofooter:
:sectanchors:
:sectnums:
:source-highlighter: pygments
:pygments-css: class
:stem: latexmath
:toc: left
:toclevels: 4
:includedir: content
:docinfo: shared

[latexmath]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\[
\def\ea{\widehat{\alpha}}
\def\eb{\widehat{\beta}}
\def\eg{\widehat{\gamma}}
\def\sep{ \quad\quad}
\newcommand{\mark}[1]{\blacktriangleright_{#1}}
\newcommand{\expr}[3]{#1\ \ \vdash\ #2\ \dashv\ \ #3}
\newcommand{\packto}[2]{#1\ \approx >\ #2}
\newcommand{\apply}[3]{#1 \bullet #2\ \Rightarrow {\kern -1em} \Rightarrow\ #3}
\newcommand{\subtype}[2]{#1\ :\leqq\ #2}
\newcommand{\braced}[1]{\lbrace #1 \rbrace}
\]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

== Intro 

Morloc is a strongly-typed functional programming language where functions are
imported from foreign languages and unified through a common type system. This
language is designed to serve as the foundation for a universal library of
functions. Each function in the library has one general type and zero or more
implementations. An implementation may be either a function sourced from a
foreign language or a composition of such functions. All interop code is
generated by the Morloc compiler.

== Why Morloc?

=== Compose functions across languages under a common type system

Morloc allows functions from polyglot libraries to be composed in a simple
functional language. The focus isn’t on classic interoperability (e.g., calling
Python from C) or serialization (e.g., sending data between applications via
protobufs) -- though morloc implementations may use these under the
hood. Instead, you define types, import implementations, and build complex
programs through function composition. The compiler invisibly generates any
required interop code.

=== Write in your favorite language, share with everyone

Do you _want_ to write in language X but _have_ to write in language Y because
everyone in your team does or because your expected users do? Love C for
algorithms, R for statistics, but don’t want to write full apps in either?
Morloc lets you mix and match, so you can use each language where it shines,
with no bindings or boilerplate.

=== Run benchmarks and tests across languages

Tired of learning new benchmark and testing suites across all your languages? Is
it hard to benchmark similar tools wrapped in applications with varying input
formats, input validation costs, or startup overhead? In Morloc, functions
with the same general type signature can be swapped in and out for benchmarking
and testing. The same test suites and test cases will work across all supported
languages because inputs/output of all functions of the same type share
equivalent Morloc binary forms, making validation and comparison easy.

=== Design universal libraries

With Morloc, we can build abstract libraries using the general types as a
logical framework. Then we can import implementations of these functions from
one or more of the supported languages and easily test and benchmark them. These
libraries are the foundation for an ecosystem where functions may be verified,
organized/searched by type, and used to build rigorous programs.

=== Make better bioinformatics workflows

Within the bioinformatics space, Morloc can serve as a replacement for the
brittle application/file paradigm of workflow design. Replace heavy CLI
applications with pure function libraries, ad hoc textual file formats with
explicit data structures, and workflow specifications with function
compositions. See the the first Morloc
paper for details (https://www.zebulun-arendsee.com/images/morloc-paper-001.pdf[pre-released here]).


// Tired of reimplementing everything in every language? In Morloc, we can define
// functions, typeclasses, and hierarchies of types. Then build universal,
// (optionally) polyglot libraries that compose across language boundaries. These
// libraries may be searched by type as well as metadata (ranging from mundane
// licensing info to exotic empirical models of performance and certificates of
// correctness). This makes it possible to build safe, verifiable, and even
// AI-assisted compositions.

// Conventional scientific workflows
//
// === Scrap your bioinformatics workflows
//
// Tired of writing wrappers, CLIs, APIs, and parsers and formatters for every
// tool? With morloc, just write clean functions and compositions -- the compiler
// can generate the rest.
//
// You can focus on writing algorithms rather than
// maintaining heavy applications.
//
// === Scrap your bespoke data formats
//
// Are you accustomed to chaining tools with text files (think bioinformatics
// pipelines)? Maybe you even thought this was "the UNIX way" and therefore a "good
// thing". But after writing your hundreth GFF parser that builds gene models from
// inconsistently formatted attribute fields, maybe you've started to have
// doubts. Morloc lets you drop the fragile formats. Instead, compose functions
// that share clear, unambiguous data structures that can be serialized
// unambiguously to JSON, MessagePack or Morloc binary format.
//
// In the bioinformatics space, Morloc can replace the f
//


// === Leave the common path
//
// Why is Python so popular? Simple. It is easy to learn, leading to high early
// adoption. After early adoption, positive feedback loops took over: Python teams
// encourage new members to use Python, growing communities create more
// high-quality libraries that attract more users. So, apart from the language's
// natural charms, its success came from social cohesive forces and ecosystem
// depth. Morloc weakens both these forces by letting teams more easily work in
// polyglot settings and by sharing ecosystems and libraries across languages. This
// decreases the cost of using specialized or exotic languages, such as BUGS/JAGS
// for Bayesian models or Futhark for parallel computing.


== Current status

Morloc is under heavy development in several areas:

 * language support - Morloc currently supports only three languages: {Cpp},
   Python, and R. Before adding more, we will further standardize the language
   onboarding process.

 * syntax - we'll soon let users define operators, add import namespaces, and more

 * type system - there is lots to do here - sum types, effect handling, constraints, extensible records 

 * performance - Morloc is pretty fast already, but there the shared library
   implementation lacks proper memory defragmenting algorithms and the language
   binders leak memory in some cases

 * scaling - I've implemented some of the infrastructure and syntax for remote
   job submission, but more work is needed before it can be used in practice

There is one island of stability, though. The native functions Morloc imports
are fully independent of Morloc. So for a given Morloc program, most of your
code will be pure functions in native languages (e.g., Python, {cpp}, or
R). This code will never have to change between Morloc versions. Where
Morloc will change is in how it describes these native functions, the syntax
it uses to compose them, and the particulars of code generation.

Is Morloc ready for production? Maybe. Currently, Morloc has some sharp
corners and new versions may make breaking changes. So Morloc is currently
most appropriate for adventorous first adopters who can solve problems and write
clear issue reports. Morloc may be around one year full-time work from
v1.0.

== Getting Started

include::{includedir}/getting-started.asc[]

// include::{includedir}/motivation.asc[]

== Syntax and Features

include::{includedir}/features.asc[]

// == Language Interoperability
//
// include::{includedir}/serialization.asc[]

== Q&A

include::{includedir}/questions-and-answers.asc[]


== Contact

include::{includedir}/contact.asc[]

// == Code Generation and Optimization
//
// include::{includedir}/code-generation.asc[]
//
// == Specification
//
// include::{includedir}/type-specification.asc[]

// == In Development
//
// include::{includedir}/refinement-types.asc[]
//
// include::{includedir}/generating-user-interfaces.asc[]
//
// include::{includedir}/effects.asc[]

// the module system and environment

// = The Future
//
// include::{includedir}/unsettled-issues.asc[]
//
// include::{includedir}/pieces.asc[]
//
// include::{includedir}/workflow.asc[]
//
// = Related work
//
// include::{includedir}/related-work.asc[]
//
// [glossary]
// = Glossary
//
// include::{includedir}/glossary.asc[]
//
// [appendix]
//
// = LOC (old version of Morloc)
//
// LOC was the first working(ish) version of Morloc
//
// include::{includedir}/LOC.asc[]


// == Acknowledgements
//
// This documentation page was built with Asciidocs -- the best markdown language ever -- and the link:https://harshkapadia2.github.io/asciidoctor-jet/[asciidoctor-jet] template made by Harsh Kapadia.


// [bibliography]
// = References
//
// bibliography::[]

// // flotsam
// include::{includedir}/old-letter.asc[]
//
// include::{includedir}/build-system.asc[]
//
// include::{includedir}/forms-of-data.asc[]
//
// include::{includedir}/function-roles.asc[]
//
// include::{includedir}/graph.asc[]
//
// include::{includedir}/manifolds-and-codegen.asc[]
//
// include::{includedir}/modules.asc[]

// DO NOT remove the HTML block below as it is required for the PWA install prompt and the 'back to top' button.
++++
<div class="pwa-install-div hidden">
	<div id="pwa-install-text">Ready for offline use!</div>
	<button id="pwa-install-btn">Install</button>
	<button id="pwa-install-dismiss" aria-label="Dismiss PWA install prompt">
		<img src="static/img/clear_cross.svg" alt="X">
	</button>
</div>

<button class="btn hidden back-to-top-btn" aria-label="Scroll to top"><img src="static/img/up-arrow.svg" alt="Top"></button>
++++
