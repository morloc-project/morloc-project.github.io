= Morloc Manual
:author: Zebulun Arendsee
:bibtex-file: references.bib
:bibtex-order: appearance
:bibtex-style: cambridge-university-press-numeric.csl
:docinfo: shared
:favicon: static/img/favicon.ico
:figure-caption!:
:icons: image
:iconsdir: static/img/admonition_icons
:imagesdir: static/img
:nofooter:
:sectanchors:
:sectnums:
:source-highlighter: pygments
:pygments-css: class
:stem: latexmath
:toc: left
:toclevels: 4
:includedir: content
:docinfo: shared
:mermaid-theme: dark
:mermaid-format: svg
:mermaid-background: transparent

[latexmath]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\[
\def\ea{\widehat{\alpha}}
\def\eb{\widehat{\beta}}
\def\eg{\widehat{\gamma}}
\def\sep{ \quad\quad}
\newcommand{\mark}[1]{\blacktriangleright_{#1}}
\newcommand{\expr}[3]{#1\ \ \vdash\ #2\ \dashv\ \ #3}
\newcommand{\packto}[2]{#1\ \approx >\ #2}
\newcommand{\apply}[3]{#1 \bullet #2\ \Rightarrow {\kern -1em} \Rightarrow\ #3}
\newcommand{\subtype}[2]{#1\ :\leqq\ #2}
\newcommand{\braced}[1]{\lbrace #1 \rbrace}
\]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

== Intro

Morloc is a strongly-typed functional programming language where functions are
imported from foreign languages and unified under a common type system. This
language is designed to serve as the foundation for a universal library of
functions. Each function in the library has one general type and zero or more
implementations. An implementation may be either a function sourced from a
foreign language or a composition of such functions. All interop code is
generated by the Morloc compiler.

== Why Morloc?

=== Compose functions across languages under a common type system

Morloc allows functions from polyglot libraries to be composed in a simple
functional language. The focus isn’t on classic interoperability (e.g., calling
Python from C) or serialization (e.g., sending data between applications via
protobufs) -- though morloc implementations may use these under the
hood. Instead, you define types, import implementations, and build complex
programs through function composition. The compiler invisibly generates any
required interop code.

=== Write in your favorite language, share with everyone

Do you _want_ to write in language X but _have_ to write in language Y because
everyone in your team does or because your expected users do? Love C for
algorithms, R for statistics, but don’t want to write full apps in either?
Morloc lets you mix and match, so you can use each language where it shines,
with no bindings or boilerplate.

=== Run benchmarks and tests across languages

Tired of learning new benchmark and testing suites across all your languages? Is
it hard to benchmark similar tools wrapped in applications with varying input
formats, input validation costs, or startup overhead? In Morloc, functions
with the same general type signature can be swapped in and out for benchmarking
and testing. The same test suites and test cases will work across all supported
languages because inputs/output of all functions of the same type share
equivalent Morloc binary forms, making validation and comparison easy.

=== Design universal libraries

With Morloc, we can build abstract libraries using the general types as a
logical framework. Then we can import implementations of these functions from
one or more of the supported languages and easily test and benchmark them. These
libraries are the foundation for an ecosystem where functions may be verified,
organized/searched by type, and used to build rigorous programs.

=== Make better bioinformatics workflows

Within the bioinformatics space, Morloc can serve as a replacement for the
brittle application/file paradigm of workflow design. Replace heavy CLI
applications with pure function libraries, ad hoc textual file formats with
explicit data structures, and workflow specifications with function
compositions. See the the first Morloc
paper for details (https://www.zebulun-arendsee.com/images/morloc-paper-001.pdf[pre-released here]).


// Tired of reimplementing everything in every language? In Morloc, we can define
// functions, typeclasses, and hierarchies of types. Then build universal,
// (optionally) polyglot libraries that compose across language boundaries. These
// libraries may be searched by type as well as metadata (ranging from mundane
// licensing info to exotic empirical models of performance and certificates of
// correctness). This makes it possible to build safe, verifiable, and even
// AI-assisted compositions.

// Conventional scientific workflows
//
// === Scrap your bioinformatics workflows
//
// Tired of writing wrappers, CLIs, APIs, and parsers and formatters for every
// tool? With morloc, just write clean functions and compositions -- the compiler
// can generate the rest.
//
// You can focus on writing algorithms rather than
// maintaining heavy applications.
//
// === Scrap your bespoke data formats
//
// Are you accustomed to chaining tools with text files (think bioinformatics
// pipelines)? Maybe you even thought this was "the UNIX way" and therefore a "good
// thing". But after writing your hundreth GFF parser that builds gene models from
// inconsistently formatted attribute fields, maybe you've started to have
// doubts. Morloc lets you drop the fragile formats. Instead, compose functions
// that share clear, unambiguous data structures that can be serialized
// unambiguously to JSON, MessagePack or Morloc binary format.
//
// In the bioinformatics space, Morloc can replace the f
//


// === Leave the common path
//
// Why is Python so popular? Simple. It is easy to learn, leading to high early
// adoption. After early adoption, positive feedback loops took over: Python teams
// encourage new members to use Python, growing communities create more
// high-quality libraries that attract more users. So, apart from the language's
// natural charms, its success came from social cohesive forces and ecosystem
// depth. Morloc weakens both these forces by letting teams more easily work in
// polyglot settings and by sharing ecosystems and libraries across languages. This
// decreases the cost of using specialized or exotic languages, such as BUGS/JAGS
// for Bayesian models or Futhark for parallel computing.


== Current status

Morloc is under heavy development in several areas:

 * *language support* – Need to streamline language onboarding and add languages
   beyond the current three (Python, R, and {cpp})

 * *type system* – There’s lots to do here: sum types, effect handling, constraints, extensible records

 * *performance* – The shared library implementation lacks proper memory
   defragmentation, and there is some unnecessary memory copying between
   languages

 * *scaling* – I’ve implemented some of the infrastructure and syntax for remote
   job submission, but more work is needed before it can be used in practice

 * *tooling* – We need a linter, debugger, better dependency management, more
   flexible builds

There is one island of stability, though: the native functions Morloc imports
are fully independent of Morloc itself. For a given Morloc program, most of your
code will be pure functions in native languages (e.g., Python, {cpp}, or
R). This code will never have to change between Morloc versions. Where Morloc
will change is in how it describes these native functions, the syntax it uses to
compose them, and the particulars of code generation.

Is Morloc ready for production? Maybe. Currently, Morloc has many sharp edges,
and new versions may introduce breaking changes. So Morloc is most appropriate
right now for adventurous first adopters who can solve problems and write clear
issue reports.

*Want to contribute?* The most helpful thing you can do is join the community (see
the Contact section), try out Morloc, and offer feedback on social media or via
GitHub issue reports. The community is just starting, and the language is young,
so you can strongly influence how the system evolves.


== Getting Started

include::{includedir}/getting-started.asc[]

// include::{includedir}/motivation.asc[]

== Syntax and Features

include::{includedir}/features.asc[]

== Modules and Libraries

include::{includedir}/ecosystem.asc[]

== Building Command Line Tools

include::{includedir}/cli.asc[]

== Summoning Daemons

include::{includedir}/daemons.asc[]

== Morloc versions and dependencies

include::{includedir}/installation.asc[]

== Internals

include::{includedir}/internals.asc[]

// == Language Interoperability
//
// include::{includedir}/serialization.asc[]

== Q&A

include::{includedir}/questions-and-answers.asc[]

== Contact

include::{includedir}/contact.asc[]


// [bibliography]
// = References
//
// bibliography::[]

// DO NOT remove the HTML block below as it is required for the PWA install prompt and the 'back to top' button.
++++
<div class="pwa-install-div hidden">
	<div id="pwa-install-text">Ready for offline use!</div>
	<button id="pwa-install-btn">Install</button>
	<button id="pwa-install-dismiss" aria-label="Dismiss PWA install prompt">
		<img src="static/img/clear_cross.svg" alt="X">
	</button>
</div>

<button class="btn hidden back-to-top-btn" aria-label="Scroll to top"><img src="static/img/up-arrow.svg" alt="Top"></button>
++++
